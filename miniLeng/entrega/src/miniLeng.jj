/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options
{
  static = true;
  ignore_case = true;
}
PARSER_BEGIN(miniLeng)
import java.io.*;
import miniLeng.Simbolo;
import miniLeng.Tabla_simbolos;
import miniLeng.Globals;
import miniLeng.RegistroExpr;
import miniLeng.ASTNode;
import miniLeng.GeneradorCodigo;
import java.util.ArrayList;
public class miniLeng
{
  public static void main(String args []) throws ParseException
  {
      BufferedReader new_buffer = new BufferedReader(new InputStreamReader(System.in));
	  String file;
	  miniLeng parser;
	  Globals variables = new Globals();
	  variables.t = new Tabla_simbolos();
	  System.out.println("Ruta y nombre del fichero:");

	  try
	  {
	    file=new_buffer.readLine();
	  }catch(IOException e) {
	    System.out.println("Error al leer la cadena");
	    return;
	  }

	  System.out.println(file);
	  try {
	    parser = new miniLeng(new FileInputStream(file));
	  }
	  catch(FileNotFoundException e) {
	    System.out.println("Fallo al leer el fichero");
	    return;
	  }
	  //tabla.inicializar_tabla();
	  try {
	    parser.programa_completo(variables);
	  }
	  catch (Error e) {
	    int linea = token.beginLine;
	    int columna = token.beginColumn;
	    String simbolo = token.image;
	    System.out.println("ERROR LÉXICO (<" + linea + ", " + columna + ">): símbolo no reconocido: <" + simbolo + ">");
	  }
  }
  /********** Tratamiento Errores **********************/
  public static void tratarErrorSintactico(int line, int column, String msg_error, Globals g) {
	System.out.println("ERROR SINTACTICO (<" + line + ", " + column + ">): Simbolo encontrado \"" + msg_error + "\"");
	g.erroresSint++;
  }
  public static void error_semantico(String msg_error, Globals g) {
	System.out.println("ERROR SEMANTICO : " + msg_error);
	g.erroresSem++;
  }
  public static void error_semantico(String msg_error, Token t, Globals g) {
    int line = t.beginLine;
    int col = t.beginColumn;
    String id = t.image;
	System.out.println("ERROR SEMANTICO (<" + line + ", " + col + ">): " + msg_error + ": \"" + id + "\"");
	g.erroresSem++;	
  }
  public static void warning(String msg_error, int line) {
	System.out.println("WARNING : linea " + line + " -- " + msg_error);
  }
  public static boolean comparar_tipos(Simbolo.TipoVariable t1, Simbolo.TipoVariable t2, Simbolo.TipoVariable tipo, int verbose, Globals g){
    boolean resul = true;
    if ( t1 != tipo && t2 != tipo )
    {
      resul = false;
      if (verbose==1) { 
        miniLeng.error_semantico("linea " + token.beginLine + "  - Los operadorores deben ser " + tipo, g);
      }      
    }
    return resul;
  }
  public static boolean validar_tipo(Simbolo.TipoVariable t, Simbolo.TipoVariable tipo, Globals g){
    boolean resul = true;
    if ( t != tipo  && t != Simbolo.TipoVariable.DESCONOCIDO)
    {
        miniLeng.error_semantico("linea " + token.beginLine + "  -  El operador debe ser " + tipo, g);
        resul=false;
    }
    return resul;
  }
  public static void createSubTreeAST(ASTNode root, ASTNode left, ASTNode right, ASTNode.TipoNodo type, Simbolo.TipoOperador op) {
     // Generacion de codigo
     root.setType(type);
     root.setTypeOp(op);
     root.setLeft(left);
     root.setRight(right);
  }
  public static boolean rango_enteros(int n) {
     return (n <= 1000 && n >= -1000) ? true : false;
  }
}
PARSER_END(miniLeng)
void programa_completo(Globals g):
{}
{
  programa(g) < EOF >
}
/*  programa ::= < tPROGRAMA > <tIDENTIFICADOR > ";"
					declaracion_variables
					declaracion_acciones
					bloque_sentencias             */
void programa(Globals g) : 
{ Token t1;
  int num_vars = 0;
  ASTNode acciones = null, sentencias = null;
}
{
  try { 
	<tPROGRAMA> t1 = <tIDENTIFICADOR> ";"
	{
	  //TODO: Comprobar que no existe otro programa <TFIN >?
	  g.nombre_prog = t1.image;
	  g.setDireccionInicial();
	  g.generarCodigoPrograma(t1.image);
	}
	num_vars = declaracion_variables(g)
	{
		g.t.introducir_programa(t1.image, 2 + num_vars);
		g.OSF_s = 2 + num_vars;
	}
	acciones = declaracion_acciones(g)
	sentencias = bloque_sentencias(g)
	{
	  if (g.erroresLex == 0 && g.erroresSem == 0 && g.erroresSint == 0) { 
	    String etiqueta;
	    // Generar código del incio del programa
	    //etiqueta = codigo.nueva_etiqueta();
	    g.codigo.escribir(";Programa " + t1.image + ".");
	    g.codigo.escribir("\tENP L0");
		// Generar código de las acciones
		g.codigo.escribir("\n;Acciones");
		g.codigo.escribir(acciones);
	    // Generar código del programa principal		
	    g.codigo.escribir("\n;Comienzo del programa " + t1.image + ".\n");
	    g.codigo.escribir("L0:");	    
		g.codigo.escribir(sentencias);
		// Fin del programa
	    g.codigo.escribir("\n;Fin de programa " + t1.image + ".\n");
	    g.codigo.escribir("\tLVP");
	    g.codigo.cerrar();
	  }	
	}
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.beginLine, token.beginColumn, token.image, g);
  }
}
/* declaracion_variables ::= (declaracion ";")* */
int declaracion_variables(Globals g) : 
{ int ret = 0, aux = 0; }
{
  try { 
    ( aux = declaracion(g) ";" { ret += aux; })*
    { return ret; }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image, g);
	return 0;
  }
}
/* declaracion ::= tipo_variables identificadores */
int declaracion(Globals g) : 
{Simbolo.TipoVariable tipoVar; int ret = 0;}
{
  try { 
    tipoVar = tipo_variables(g) ret = identificadores(g, tipoVar)
    { return ret; }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image, g);
	return 0;
  }
}
/* identificadores ::= < tIDENTIFICADOR > ( "," < tIDENTIFICADOR >)* */
int identificadores(Globals g, Simbolo.TipoVariable tipoVar) : 
{ Token t1,t2; Simbolo s; int ret = 0; }
{
  try { 
    t1 = < tIDENTIFICADOR >
	{
	  //TODO: Puede ser otro tipo de error
	  s =  g.t.buscar_simbolo(t1.image, g.nivel, Simbolo.TipoSimbolo.VAR_PARAM);
		if ( s != null && s.esVisible() ) 
		    miniLeng.error_semantico("Identificador duplicado", t1, g);
		else { 
			g.t.introducir_variable(t1.image, tipoVar, g.nivel, g.dir);
			g.dir++;
			ret++;
		}
	}
     ( "," t2 = < tIDENTIFICADOR>
	{
	  s =  g.t.buscar_simbolo(t2.image, g.nivel, Simbolo.TipoSimbolo.VAR_PARAM);
		if ( s != null && s.esVisible() ) 
		    miniLeng.error_semantico("Identificador duplicado", t2, g);
		else { 
			g.t.introducir_variable(t2.image, tipoVar, g.nivel, g.dir);
			g.dir++;
			ret++;
		}
	}	
     )*
     { return ret; }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image, g);
	return 0;       
  }
}
/***************************************************************************************************
***************************************************************************************************/
/******************************************** Acciones ********************************************/
/* declaracion_acciones ::= (declaracion_accion)* */
ASTNode declaracion_acciones(Globals g) : 
{
  ASTNode accion = null, resul = null, aux = null;
}
{
  try { 
    (
      accion = declaracion_accion(g)
	{
	  if(resul == null) {
	    resul = accion;
	  }
	  else {
	    // Se anida en el punter ASTNode.next
	    aux = resul;
		while(aux.getNext() != null){
			aux = aux.getNext();
		}
		aux.setNext(accion);
	  }
	}
    )*
    { return resul; }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image, g);
	return null;        
  }
}
/* declaracion_accion ::= cabecera_accion ";"
							declaracion_variables
							declarracion_acciones
							bloque sentencias	*/
ASTNode declaracion_accion(Globals g) : 
{
  int num_vars = 0;
  RegistroExpr cabecera = null;
  ASTNode acciones = null,
          sentencias = null;
}
{
  try { 
    cabecera = cabecera_accion(g) ";"
	num_vars = declaracion_variables(g)
	{
		g.OSF_s += num_vars;
		cabecera.s.setDir(g.OSF_s);
	}
	acciones = declaracion_acciones(g) 
	sentencias = bloque_sentencias(g)
	{
	  //Eliminamos variables del bloque y bajamos un nivel
	  g.t.eliminar_variables(g.nivel);
	  g.t.eliminar_acciones(g.nivel);
	  g.t.ocultar_parametros(g.nivel);
	  g.t.eliminar_parametros_ocultos(g.nivel);
	  g.nivel--;
	  g.OSF_s -= num_vars;
	  //Generamos rama del árbol AST ( raiz: nodo-accion ; izq: parametros de la accion ; der: bloque_sentencias)
      if(cabecera.nodoAST != null) {
    	  cabecera.nodoAST.setNext(acciones);
    	  cabecera.nodoAST.setRight(sentencias);
      }
	  return cabecera.nodoAST;
	}
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image, g);
	return null;   
  }
}
/* cabecera_accion ::= < tACCION > < tIDENTIFICADOR > (parametros_formales)? */
RegistroExpr cabecera_accion(Globals g) : 
{
  Token t1;
  Simbolo s = null;
  ASTNode resul = null, params = null;
  RegistroExpr reg_resul = new RegistroExpr();
 }
{
  try { 
    < tACCION >
    t1 = < tIDENTIFICADOR >
	{
	  //Introduce en la tabla la accion
	  if ( g.t.buscar_simbolo(t1.image, g.nivel, Simbolo.TipoSimbolo.ACCION) != null ) {
		// Existe el simbolo en el mismo nivel
		miniLeng.error_semantico("Identificador duplicado", t1, g);
	  }
	  else{
	    s = g.t.introducir_accion(t1.image,g.nivel,g.dir, g.codigo.nueva_etiqueta());
	  	resul = new ASTNode(s.getEtiqueta(), s.getNivel(), ASTNode.TipoNodo.FUN);
	  }
	  g.setDireccionInicial();
	  g.nivel++;
	}
   (params = parametros_formales(g, s) { if(resul != null) resul.setLeft(params); })?
   {
	 reg_resul.s = s;
	 reg_resul.nodoAST = resul;
     return reg_resul;
     }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image, g);
	return null;     
  }
}
/* parametros_formales ::= ( "(" parametros ")")? */
ASTNode parametros_formales(Globals g, Simbolo s) : 
{ASTNode params = null; }
{
  try { 
	 "(" (params = parametros(g, s))? ")"
	 {	return params; }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image, g);
	return null;   
  }
}
/* lista_parametros ::= identificadores (";" paraemtros)? */
ASTNode lista_parametros(Globals g, Simbolo s_accion, Simbolo.TipoVariable tipoVar, Simbolo.ClaseParametro tipoParam) : 
{Token t1, t2;
 int n = 0;
 Simbolo s = null;
 ASTNode params = null, aux = null, resul = null;
}
{
  try { 
    t1 = < tIDENTIFICADOR >
	{
	     //Aumento el contador de parametros de la accion 
	  //TODO: Puede ser otro tipo de error
		if (g.t.buscar_simbolo(t1.image, g.nivel, Simbolo.TipoSimbolo.VAR_PARAM) != null) { 
		    miniLeng.error_semantico("Identificador duplicado", t1, g);
		    if ( s_accion != null ) {
		      s_accion.add_param();
		      g.t.introducir_parametro(t1.image, Simbolo.TipoVariable.DESCONOCIDO, tipoParam, g.nivel, g.dir);
		      g.dir++;
		    }
		}
		else {
			s = g.t.introducir_parametro(t1.image, tipoVar, tipoParam, g.nivel, g.dir);
			//s.setClaseSimbolo(Simbolo.ClaseSimbolo.PARAMETRO);
			if (s_accion != null && s_accion.esAccion()) {
			    s_accion.add_param();
				s_accion.introducir_parametro(t1.image, tipoVar, tipoParam, g.nivel);
				resul = new ASTNode(t1.image, g.nivel, tipoVar);
			    resul.setType(ASTNode.TipoNodo.VAR);
			    resul.setTypeParam(tipoParam);
		        resul.setDir(g.dir);
		        // Sumo a dir del simbolo para hacer la llamada OSF
				n = s_accion.getDir() + ((tipoParam == Simbolo.ClaseParametro.REF) ? 1 : 2);
		        s_accion.setDir(n);
			}
			g.dir++;
		}
	}
     ( "," t2 = < tIDENTIFICADOR >
	{
		if ( g.t.buscar_simbolo(t2.image, g.nivel, Simbolo.TipoSimbolo.VAR_PARAM) != null) { 
		    miniLeng.error_semantico("Identificador duplicado", t2, g);
		    if ( s_accion != null ) {
		      s_accion.add_param();
		      g.t.introducir_parametro(t2.image, Simbolo.TipoVariable.DESCONOCIDO, tipoParam, g.nivel, g.dir);
		      g.dir++;
		    }
		}
		else { 
			s = g.t.introducir_parametro(t2.image, tipoVar, tipoParam, g.nivel, g.dir);
			//s.setClaseSimbolo(Simbolo.ClaseSimbolo.PARAMETRO);
			if ( s_accion != null && s_accion.esAccion()){
			    s_accion.add_param();
				s_accion.introducir_parametro(t2.image, tipoVar, tipoParam, g.nivel);
				// Se introducen en el arbol AST de forma inversa para poder salvarse en el marco de pila
				aux = resul;
		        resul = new ASTNode(t2.image, g.nivel, tipoVar);
		        resul.setType(ASTNode.TipoNodo.VAR);
		        resul.setTypeParam(tipoParam);
		        resul.setDir(g.dir);
		        resul.setLeft(aux);
		        // Sumo a dir del simbolo para hacer la llamada OSF
		        n = s_accion.getDir() + ((tipoParam == Simbolo.ClaseParametro.REF) ? 1 : 2);
		        s_accion.setDir(n);
		        g.dir++;
			}
		}
	}	
     )*
     ( ";" params = parametros(g, s_accion))?
    {
      // Encadenar el resto de parametros
      if(s_accion != null ) {
          if(params != null) {
            aux = resul;
		    resul = params;
		    resul.setLeft(aux);
	      }
	      resul.setValue(s_accion.getDir());
  	  }
   	  return resul;
    }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image, g);
	return null;     
  }
}
/* parametros ::= clase_parametros tipo_variables lista_parametros */
ASTNode parametros(Globals g, Simbolo s) : 
{
  Simbolo.TipoVariable tipoVar;
  Simbolo.ClaseParametro tipoParam;
  ASTNode params = null;
 }
{
  try { 
    tipoParam = clase_parametros(g) tipoVar = tipo_variables(g) params = lista_parametros(g, s, tipoVar, tipoParam)
    {  return params; }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image, g);
	return null; 
	return null;    
  }
}
/***************************************************************************************************
***************************************************************************************************/
/******************************************* Sentencias *******************************************/
/* bloque_sentencias ::= < tPRINCIPIO > lista_sentencias < tFIN > */
ASTNode bloque_sentencias(Globals g) : 
{ ASTNode resul = null; }
{
  try { 
    < tPRINCIPIO > resul = lista_sentencias(g) < tFIN >
    {
      return resul;
    }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image, g);
	return null;       
  }
}
/* lista_sentencias ::= ( sentencia )* */
ASTNode lista_sentencias(Globals g) : 
{ ASTNode resul = new ASTNode(), aux;
  ArrayList<ASTNode> sentencias = new ArrayList<ASTNode>();
  boolean ok = true;
}
{
  try { 
    ( aux = sentencia(g)
	{
		//Generacion de código
		if(aux == null) {
		    ok = false;
		}
		else { 
			sentencias.add(aux);
		}
	}
    )*
    {
      if(ok) { 
	      aux = resul;
	      for(ASTNode sentencia : sentencias) {
			aux.setNext(sentencia);
			aux=sentencia;
	      }
	      resul = resul.getNext();
      }
      else {
          resul = null;
      }
      return resul;
    }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image, g);
	return null;     
  }
}
/* sentencia ::= asignacion | invoacion_accion | mientras_que | leer | escribir | selecion */
ASTNode sentencia(Globals g) : 
{Token t;
 ASTNode resul = null;
}
{
  try { 
	  t = < tIDENTIFICADOR >
	 [ 
		   resul = asignacion(g, t) 		{ return resul;	}
		 | resul = invocacion_accion(g, t)  { return resul;	}
	 ]
	| resul = mientras_que(g) 				{ return resul; }
	| resul = leer(g) ";"					{ return resul; }
	| resul = escribir(g) ";" 				{ return resul; }			
	| resul = seleccion(g) 					{ return resul;	}
	{
	  return resul;
	}
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image, g);
	return null;      
  }
}
/* asignacion ::= < tOPAS > expresion ";" */
ASTNode asignacion(Globals g, Token t) :
{
 RegistroExpr r;
 Simbolo s;
 Simbolo.TipoVariable tipo;
 Boolean ok = true;
 ASTNode node = null;
}
{
  try { 
     < tOPAS >
     {
        //TODO: Realizar mas comprobaciones, comprobar que es una variable
        // Comprobar que existe el identificador
        if ( (s = g.t.buscar_simbolo(t.image, Simbolo.TipoSimbolo.VAR_PARAM)) == null ){
            miniLeng.error_semantico("Identificador desconocido en la parte izquierda de la asignacion", t, g);
            tipo = Simbolo.TipoVariable.DESCONOCIDO;
            ok = false;
        }
        else if (s.esParametro() && s.esValor()){
            miniLeng.error_semantico("No se permote realizar una asignacion a un parametro pasado como valor", t, g);
            tipo = Simbolo.TipoVariable.DESCONOCIDO;
            ok = false;
        }
        else{
            tipo = s.getVariable();
        }
     }
     r = expresion(g) ";"
     {
        //TODO: Realizar mas comprobaciones
        if ( ok && (r.tipoVar != tipo) && !comparar_tipos(r.tipoVar, tipo, Simbolo.TipoVariable.DESCONOCIDO,0, g))
        {
            miniLeng.error_semantico("Tipos incompatibles en la asignacion", t, g);
        }
        else if (ok) {
            // Insertar nodo ASG en AST (Left: variable, Right: expresion)
			node = new ASTNode();
			node.setType(ASTNode.TipoNodo.ASG);
			node.setNivel(g.nivel);
			node.setLeft(new ASTNode(t.image, s.getNivel(), s.getDir()));
			node.getLeft().setTypeParam(s.getParametro());
			node.setRight(r.nodoAST);
        }
        return node;
     }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image, g);
	return null;   
  }
}
/* invocacion_accion ::= argumentos ";" */
ASTNode invocacion_accion(Globals g, Token t) :
{
  Simbolo s;
  boolean ok = true, args = false;
  ASTNode resul = null, argsAST = null;
}
{
  try { 
     {
        //TODO: Realizar mas comprobaciones, buscar por tipo (puede ser una variable)
        // Comprobar que existe el identificador
        if ( (s = g.t.buscar_simbolo(t.image, Simbolo.TipoSimbolo.ACCION)) == null ){
            miniLeng.error_semantico("Identificador desconocido en la llamada a la accion", t, g);
            ok = false;
        }
        else if (!s.esAccion()){
            miniLeng.error_semantico("No se puede realizar una llamda a una accion sobre un parametro", t, g);
            ok = false;
        }
        else {
            resul = new ASTNode(s.getNombre(), g.nivel, ASTNode.TipoNodo.INVOCACION);
            resul.setCond(new ASTNode(s.getEtiqueta(), g.OSF_s));
            resul.getCond().setNivel(s.getNivel());
       }
     }
	 ( argsAST = argumentos(g, s) { args=true; })? ";"
	 {
		// Compruebo los parametros de la invocacción en caso de llamarse sin parametros
      	if(!args && s!= null && s.getNum_params() != 0) {
        	miniLeng.error_semantico("linea " + token.beginLine + "  -  Se esperaban " + s.getNum_params() + " parámetros al invocar a la accion " + s.getNombre(), g);
    	}
    	else if (args && ok){
    	  //invertir argumentos para crear estructura de pila
			resul.setLeft(argsAST);
			resul.getCond().setValue(s.getDir());
    	}
    	return resul;
     }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image, g);
	return null;       
  }
}
/* mientras_que ::= < tMQ > expresion lista_sentencias < tFMQ > */
ASTNode mientras_que(Globals g) :
{ RegistroExpr r; boolean ok;
  ASTNode nodoWhile = null, sentencias;
}
{
  try { 
    < tMQ > r = expresion(g)
     {
        //TODO: Comprobar codigo muerto
        ok = validar_tipo(r.tipoVar, Simbolo.TipoVariable.BOOLEANO, g);
        if ( ok && r.tipoSimb == Simbolo.TipoSimbolo.CONST && r.valorBool == true  ) {
			miniLeng.warning("Generacion de código muerto", token.beginLine);
		}
		if (ok) {
			nodoWhile = new ASTNode("while", g.nivel, ASTNode.TipoNodo.WHILE);
			nodoWhile.setCond(r.nodoAST);
		}
     }
    sentencias = lista_sentencias(g)
    < tFMQ >
    {
		nodoWhile.setRight(sentencias);
		return nodoWhile;
    }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image, g);
	return null;     
  }
}
/* seleccion ::= < tSI > expresion < tENT > lista_sentencias ( < tSI_NO > lista_sentencias )? < tFSI > */
ASTNode seleccion(Globals g) :
{  RegistroExpr r; boolean ok;
   ASTNode nodoSeleccion = null, sentenciasL=null, sentenciasR=null;}
{
  try { 
	 < tSI > r = expresion(g)
     {
        //TODO: Comprobar codigo muerto
        ok=validar_tipo(r.tipoVar, Simbolo.TipoVariable.BOOLEANO, g);
        if ( ok && r.tipoSimb == Simbolo.TipoSimbolo.CONST) {
			miniLeng.warning("Generacion de código muerto en la sentencia if", token.beginLine);
		}
		if (ok) {
			nodoSeleccion = new ASTNode("if", g.nivel, ASTNode.TipoNodo.IF);
			nodoSeleccion.setCond(r.nodoAST);
		}
     }
	< tENT >
	sentenciasL = lista_sentencias(g)
	{
	  if(ok)
	   nodoSeleccion.setLeft(sentenciasL);
	}
	(< tSI_NO >
	sentenciasR = lista_sentencias(g)
	)?  
	< tFSI >
	{
	   if (ok) { 
		nodoSeleccion.setRight(sentenciasR);
	   }
	   return nodoSeleccion;
    }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image, g);
	return null;  
  }
}
/* leer ::= < tLEER > "(" lista_asignables ")" */
ASTNode leer(Globals g) :
{ ASTNode nodo_leer = null; }
{
  try { 
   <tLEER> "(" nodo_leer = lista_asignables(g) ")"
   { return nodo_leer; }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image, g);
	return null;     
  }
}
/* escribir ::= < tESCRIBIR > "(" lista_escribibles ")" */
ASTNode escribir(Globals g) :
{ ASTNode resul = null; }
{
  try { 
   <tESCRIBIR> "(" resul = lista_escribibles(g) ")"
   { return resul; }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image, g);
	return null;      
  }
}
/* lista_asignables ::= identificadores */
ASTNode lista_asignables(Globals g) :
{
  Token t1, t2;
  Simbolo s;
  ASTNode aux = null, resul = new ASTNode("rd", g.nivel, ASTNode.TipoNodo.RD);
}
{
  try {
    // Estructura AST para operación de lectura:
    // Se encadenan las variables en la rama derecha
    //  1ª var - > right, 2ª var right.right ....
  	t1 = < tIDENTIFICADOR>
	{
	   // Comprobar si existe en la tabla de simbolos
	   if ( (s = g.t.buscar_simbolo(t1.image, Simbolo.TipoSimbolo.VAR_PARAM)) == null ) {
	     miniLeng.error_semantico("Identificador desconocido", t1, g);
	   }
	   else if( s.getTipo() != Simbolo.TipoSimbolo.VARIABLE 
	   			&& s.getVariable() != Simbolo.TipoVariable.DESCONOCIDO
	   			&& ( !s.esChar() && !s.esCadena() && !s.esEntero())) {
		 miniLeng.error_semantico("Tipo de variable no válida en llamada a leer()", t1, g);
	   }
	   else if ( s.esVariable() && s.esValor()){
	   	miniLeng.error_semantico("No se pueda usar una variable por valor en la operacion leer", t1, g);
	   }
	   else {
	     resul.setNivel(g.nivel);
	     // Crea estructura AST
		 resul.setRight(new ASTNode(t1.image,s.getNivel(), s.getVariable()));
		 resul.getRight().setType(ASTNode.TipoNodo.VAR);
		 resul.getRight().setDir(s.getDir());
		 resul.getRight().setTypeParam(s.getParametro());
	   }
	}
  	( "," t2 = < tIDENTIFICADOR>
	{
	   // Comprobar si existe en la tabla de simbolos
	   if ( (s = g.t.buscar_simbolo(t2.image,g.nivel)) == null ) {
	     miniLeng.error_semantico("Identificador desconocido", t2, g);
	   }
	   else if( s.getTipo() != Simbolo.TipoSimbolo.VARIABLE 
	   			&& s.getVariable() != Simbolo.TipoVariable.DESCONOCIDO
	   			&& ( !s.esChar() && !s.esCadena() && !s.esEntero())) {
		 miniLeng.error_semantico("Tipo de variable no válida en llamada a leer()", t1, g);
	   }
	   else if ( s.esVariable() && s.esValor()){
	   	miniLeng.error_semantico("No se pueda usar una variable por valor en la operacion leer", t2, g);
	   }
	   else {
	     aux = resul;
	     while(aux.getRight() != null) {
			aux = aux.getRight();
	     }
		 aux.setRight(new ASTNode(t2.image, s.getNivel(), s.getVariable()));
		 aux.getRight().setType(ASTNode.TipoNodo.VAR);
		 aux.getRight().setTypeParam(s.getParametro());
		 aux.getRight().setDir(s.getDir()); 
	   }
	}
  	)*
  	{ return resul; }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image, g);
	return null;       
  }
}
/* lista_escribibles ::= (< tCONSTCAD > | < tCONSTCHAR >) ( "," (< tIDENTIFICADOR > | < tENTACAR >"("expresion")"))* */
ASTNode lista_escribibles(Globals g) : 
{  RegistroExpr r = null;
   Token t = null;
   Simbolo s;
   boolean constCad = false, entCar = false;
   ASTNode aux = null, resul = new ASTNode("wr", g.nivel, ASTNode.TipoNodo.WR);
}
{
  try {
    ( t = < tCONSTCAD >  { constCad = true; }
   	|  t = < tCONSTCHAR >  { constCad = true; }
   	|  t = < tIDENTIFICADOR >
   	|  < tENTACAR > "(" r = expresion(g) ")" { entCar = true; }
   	)
	{
		if (constCad) {
			 resul.setRight(new ASTNode(t.image, g.nivel, Simbolo.TipoVariable.CADENA));
			 resul.getRight().setType(ASTNode.TipoNodo.CONST);
		}
		else if (entCar) {
		    if(r.tipoVar != Simbolo.TipoVariable.ENTERO ) {
				miniLeng.error_semantico("Se esperaba una expresion del tipo ENTERO en la funcion entacar", token,  g);
		    }
		    else if (r.tipoSimb == Simbolo.TipoSimbolo.CONST) {
		        resul.setRight(new ASTNode(Integer.toString(r.valorEnt), g.nivel, Simbolo.TipoVariable.ENTERO));
			    resul.getRight().setType(ASTNode.TipoNodo.CONST);
		    }
		    else {
	        	resul.setRight(new ASTNode("entcar", g.nivel, ASTNode.TipoNodo.ENTCAR));
	        	resul.getRight().setTypeVar(Simbolo.TipoVariable.ENTERO);
				resul.getRight().setLeft(r.nodoAST);
	        }
		}
		else {
		    if ( (s = g.t.buscar_simbolo(t.image,Simbolo.TipoSimbolo.VAR_PARAM)) == null ) {
	           miniLeng.error_semantico("Identificador desconocido", t, g);
	        }
	        else if(!s.esChar() && !s.esCadena() && !s.esEntero()) {
		      miniLeng.error_semantico("Tipo de variable no válida en llamada a escribir", t, g);
	        }
	        else {
	          resul.setNivel(g.nivel);
	          resul.setRight(new ASTNode(t.image, s.getNivel(), s.getVariable()));
			  resul.getRight().setType(ASTNode.TipoNodo.VAR);
			  resul.getRight().setTypeParam(s.getParametro());
			  resul.getRight().setDir(s.getDir());
	        }
	     }
	     aux = resul.getRight();
	     constCad = false; entCar = false;
	}
   ( ","  
   	( t = < tCONSTCAD > { constCad = true; }
   	|  t = < tCONSTCHAR >  { constCad = true; }
   	|  t = < tIDENTIFICADOR > 
   	|  < tENTACAR > "(" r = expresion(g) ")" { entCar = true; }
    )
	{
		if (constCad) {
		     aux.setRight(new ASTNode(t.image, g.nivel, Simbolo.TipoVariable.CADENA));
		     aux.getRight().setType(ASTNode.TipoNodo.CONST);
		     aux = aux.getRight();
		}
		else if (entCar) {
		    if(r.tipoVar != Simbolo.TipoVariable.ENTERO ) {
				miniLeng.error_semantico("Se esperaba una expresion del tipo ENTERO en la funcion entacar", token,  g);
		    }
		    else if (r.tipoSimb == Simbolo.TipoSimbolo.CONST) {
		      	aux.setRight(new ASTNode(Integer.toString(r.valorEnt), g.nivel, Simbolo.TipoVariable.ENTERO));
			    aux.getRight().setType(ASTNode.TipoNodo.CONST);
		        aux = aux.getRight();
		    }
		    else {
			  	aux.setRight(new ASTNode("entcar", g.nivel, ASTNode.TipoNodo.ENTCAR));
		        aux.getRight().setTypeVar(Simbolo.TipoVariable.ENTERO);
				aux.getRight().setLeft(r.nodoAST);
		        aux = aux.getRight();
		    }
		}
		else {
		    if ( (s = g.t.buscar_simbolo(t.image,Simbolo.TipoSimbolo.VAR_PARAM)) == null ) {
	           miniLeng.error_semantico("Identificador desconocido", t, g);
	        }
	        else if(!s.esChar() && !s.esCadena() && !s.esEntero()) {
		      miniLeng.error_semantico("Tipo de variable no válida en llamada a escribir", t, g);
	        }
	        else {	  
		         aux.setRight(new ASTNode(t.image, g.nivel, s.getVariable()));
		         aux.getRight().setDir(s.getDir());
		         aux.getRight().setType(ASTNode.TipoNodo.VAR);
		         aux.getRight().setTypeParam(s.getParametro());
		         aux = aux.getRight();
	        }
	     }
	     constCad = false; entCar = false;
	}	
   )*
  {
    return resul;
  }
  }
  catch (Exception e) {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image, g);
	return null;      
  }
}
/* argumentos ::= ( "(" lista_expresiones ")" )? */
ASTNode argumentos(Globals g, Simbolo s) : 
{
  boolean ok=false;
  ASTNode resul = null;
}
{
  try { 
    "(" ( resul = lista_expresiones(g, s) { ok=true; })? ")"
    {
		// Compruebo los parametros de la invocacción en caso de llamarse sin parametros
      	if(!ok && s != null && s.getNum_params() != 0) {
        	miniLeng.error_semantico("linea " + token.beginLine + "  -  Se esperaban " + s.getNum_params() + " parámetros al invocar a la accion " + s.getNombre(), g);
        	resul = null;
    	}
    	return resul;
    }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image, g);
	return null;     
  }
}
/* lista_expresiones ::= expresion ( "," expresion)* */
ASTNode lista_expresiones(Globals g, Simbolo s) : 
{
  RegistroExpr r;
  int num_params = 0;
  boolean ok = true;
  ArrayList<Simbolo> parametros = null;
  ASTNode aux = null, resul = null;
}
{
  try { 
    r = expresion(g)
    {
      	if (s != null) {
      	    parametros = s.getLista_simbolos();
	    	num_params++;
	    	if(num_params > parametros.size()) {
				miniLeng.error_semantico("El número de parámetros de llamada a la función " + s.getNombre() + " no coindice, se esperaban " + parametros.size(), token, g);
				ok = false;
	     	}
	    	else if(!miniLeng.validar_tipo(r.tipoVar, parametros.get(num_params-1).getVariable(), g)) {
				miniLeng.error_semantico("Los tipos en la llamada a la función " + s.getNombre() + " no coindicen", g);
				ok = false;
			}
			else if (r.clase == Simbolo.ClaseParametro.VAL && !parametros.get(num_params-1).esValor() ) {
				miniLeng.error_semantico("No se puede pasar un parámetro por valor como referencia en la invocación a la accion", g);
				ok = false;
			}
			else {
				r.nodoAST.setTypeParam(parametros.get(num_params-1).getParametro());
				resul = r.nodoAST;
				resul.setTypeParam(parametros.get(num_params-1).getParametro());
			}
		}
    }
    ( "," r = expresion(g)
    {
        if ( ok && s != null) {
	    	num_params++;
	    	if(num_params > parametros.size()) {
				miniLeng.error_semantico("El número de parámetros de llamada a la función " + s.getNombre() + " no coindice, se esperaban " + parametros.size(), token, g);
				ok = false;
	     	}
	    	else if(!miniLeng.validar_tipo(r.tipoVar, parametros.get(num_params-1).getVariable(), g)) {
				miniLeng.error_semantico("Los tipos en la llamada a la función " + s.getNombre() + " no coindicen", g);
				ok = false;
			}
			else if (r.clase == Simbolo.ClaseParametro.VAL && parametros.get(num_params-1).esValor() ) {
				miniLeng.error_semantico("No se puede pasar un parámetro por valor como referencia en la invocación a la accion", g);
				ok = false;
			}
			else {
				r.nodoAST.setTypeParam(parametros.get(num_params-1).getParametro());
				aux = resul;
				resul = r.nodoAST;
				resul.setTypeParam(parametros.get(num_params-1).getParametro());
				resul.setLeft(aux);
			}
		}
    }
    )*
    {
        if ( ok && s != null ) { 
	        // Añadimos a Cond un nodo con los datos de la accion (etiqueta, num parametros y nivel)
	        // Se añade siempre al inicio, dejando la primera expresion al final
	      	resul.setCond(new ASTNode(s.getEtiqueta(), s.getDir()));
	      	resul.getCond().setNivel(s.getNivel());
			// Comprobar que los parametros de llamada a la funcion coindicen con los de la tabla
			if (s.getNum_params() != num_params) {
				miniLeng.error_semantico("El número de parámetros de llamada a la función " + s.getNombre() + " no coindice, se esperaban " + parametros.size(), token, g);
				resul = null;
			}
		}
		return resul;
    }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image, g);
	return null;      
  }
}
/* expresion ::= expresion_simple | (operador_relacional expresion_simple)* */
RegistroExpr expresion(Globals g) : 
{ 
  RegistroExpr r1 = null, r2=null;
  RegistroExpr resul = new RegistroExpr();
  ASTNode aux = null;
  Simbolo.TipoOperador op;
  Boolean ok, optimizar = false, anidar = false;
}
{
  try {
    {  resul.nodoAST = new ASTNode("op", g.nivel);  }
	r1 = expresion_simple(g)
	(op =operador_relacional(g)
	 r2 = expresion_simple(g)
	{
	  	// Analisis semantico:
	  	ok = true;
		if((r1.tipoVar != r2.tipoVar) && !comparar_tipos(r1.tipoVar,r2.tipoVar, Simbolo.TipoVariable.DESCONOCIDO,0, g)) {
		    miniLeng.error_semantico("Los operandos deben ser del mismo tipo", token, g);
		    resul.tipoVar = Simbolo.TipoVariable.DESCONOCIDO;
		}
		else {
		    resul.tipoVar = Simbolo.TipoVariable.BOOLEANO;
		    // Optimización en caso de constantes
		    switch (r1.tipoVar) {
				case ENTERO:
					ok = validar_tipo(r2.tipoVar, Simbolo.TipoVariable.ENTERO, g);
					if ( !ok )
						resul.tipoVar = Simbolo.TipoVariable.DESCONOCIDO;
					else if (r1.tipoSimb == Simbolo.TipoSimbolo.CONST && r2.tipoSimb == Simbolo.TipoSimbolo.CONST) {
				    	resul.tipoSimb = Simbolo.TipoSimbolo.CONST;
				    	optimizar = true;
					    switch (op) {
                   			case GT:
                        		resul.valorBool = r1.valorEnt > r2.valorEnt;
            		    		break;
            	    		case LT:
                        		resul.valorBool = r1.valorEnt < r2.valorEnt;
            		    		break;
            	    		case GE:
                        		resul.valorBool = r1.valorEnt >= r2.valorEnt;
            					break;
            	    		case LE:
                        		resul.valorBool = r1.valorEnt <= r2.valorEnt;
            					break;
             	    		case EQ:
                         		resul.valorBool = r1.valorEnt == r2.valorEnt;
             					break;
            	    		case NE:
                        		resul.valorBool = r1.valorEnt != r2.valorEnt;
            					break;
            	    		default:
            		    		break;
                		}
              		}
					break;
				case CADENA:
					ok = validar_tipo(r2.tipoVar, Simbolo.TipoVariable.CADENA, g);
					if ( !ok )
						resul.tipoVar = Simbolo.TipoVariable.DESCONOCIDO;
					else if (r1.tipoSimb == Simbolo.TipoSimbolo.CONST && r2.tipoSimb == Simbolo.TipoSimbolo.CONST) {
						optimizar = true;
					    switch (op) {
             	    		case EQ:
                         		resul.valorBool = r1.valorString.equals(r2.valorString);
             					break;
            	    		case NE:
                        		resul.valorBool = !r1.valorString.equals(r2.valorString);
            					break;
            	    		default:
            	    		    miniLeng.error_semantico("No se puede utilizar el operador " + op + " sobre una cadena", g);
            		    		break;
                		}
              		}
					break;
				case BOOLEANO:
					ok = validar_tipo(r2.tipoVar, Simbolo.TipoVariable.BOOLEANO, g);
					if ( !ok )
						resul.tipoVar = Simbolo.TipoVariable.DESCONOCIDO;
					else if (r1.tipoSimb == Simbolo.TipoSimbolo.CONST && r2.tipoSimb == Simbolo.TipoSimbolo.CONST) {
						optimizar = true;
					    switch (op) {
             	    		case EQ:
                         		resul.valorBool = r1.valorBool == r2.valorBool;
             					break;
            	    		case NE:
                        		resul.valorBool = r1.valorBool != r2.valorBool;
            					break;
            	    		default:
            	    		    miniLeng.error_semantico("No se puede utilizar la operador " + op + " sobre un booleano", g);
            		    		break;
                		}
              		}				
					break;
				case DESCONOCIDO:
					resul.tipoVar = Simbolo.TipoVariable.DESCONOCIDO; 
				default: // DESCONOCIDO
					break;
		    }
		    resul.nodoAST = new ASTNode("bool", g.nivel, ASTNode.TipoNodo.CONST);
            resul.nodoAST.setValue(((resul.valorBool) ? 1 : 0));
			resul.nodoAST.setTypeVar(Simbolo.TipoVariable.BOOLEANO);
		}
  	  	if (ok && !optimizar) {
  	  	  if(!anidar){
  	  	  	miniLeng.createSubTreeAST(resul.nodoAST, r1.nodoAST, r2.nodoAST, ASTNode.TipoNodo.OP,op);
  	  	  	aux = resul.nodoAST;
  	  	  	anidar = true;
  	  	  }
  	  	  else{
  	  	    resul.nodoAST = new ASTNode("op", g.nivel);
  	  	  	miniLeng.createSubTreeAST(resul.nodoAST, aux, r2.nodoAST, ASTNode.TipoNodo.OP,op);
			aux = resul.nodoAST;
  	  	  }  	  
  	  	}
	}
	)*
	{
	  if (r2 == null)
	    return r1;
	  else
	    return resul;
	}
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image, g);
	return null;        
  }
}
/* expresion_simple ::= termino (operador_aditivo termino)* */
RegistroExpr expresion_simple(Globals g) : 
{
  RegistroExpr r1 = null, r2=null;
  RegistroExpr resul = new RegistroExpr();
  ASTNode aux = null;
  Simbolo.TipoOperador op;
  Boolean ok = false, optimizar = false, anidar = false;
}
{
  try {
	{  resul.nodoAST = new ASTNode("op", g.nivel);  }
	r1 = termino(g)
	( op = operador_aditivo(g)
	  r2 = termino(g)
	{
	  if ( op == Simbolo.TipoOperador.OR ) {
			ok = validar_tipo(r1.tipoVar, Simbolo.TipoVariable.BOOLEANO, g)
		        && validar_tipo(r2.tipoVar, Simbolo.TipoVariable.BOOLEANO, g);
		    if (!ok) {
                miniLeng.error_semantico("Incompatibilidad de tipos en la operacion", token, g);
                resul.tipoVar = Simbolo.TipoVariable.DESCONOCIDO;				
		    }
		    else {
		        resul.tipoVar = Simbolo.TipoVariable.BOOLEANO;
		      // Si son constantes optimizo realizando la operacion
				if(r1.tipoSimb == Simbolo.TipoSimbolo.CONST && r2.tipoSimb == Simbolo.TipoSimbolo.CONST) {
				    resul.tipoSimb = Simbolo.TipoSimbolo.CONST;
				    optimizar = true;
                	resul.valorBool = r1.valorBool | r2.valorBool;
                	resul.nodoAST = new ASTNode("bool", g.nivel, ASTNode.TipoNodo.CONST);
                	resul.nodoAST.setValue(((resul.valorBool) ? 1 : 0));
					resul.nodoAST.setTypeVar(Simbolo.TipoVariable.BOOLEANO);
				}
				else if(r1.tipoVar == Simbolo.TipoVariable.DESCONOCIDO
						|| r2.tipoVar == Simbolo.TipoVariable.DESCONOCIDO)
				{
				  resul.tipoVar = Simbolo.TipoVariable.DESCONOCIDO;
				} 
		    }
  	  	}
  	  	else {
		    ok = validar_tipo(r1.tipoVar, Simbolo.TipoVariable.ENTERO, g)
		        && validar_tipo(r2.tipoVar, Simbolo.TipoVariable.ENTERO, g);
		    if (!ok) {
                miniLeng.error_semantico("Incompatibilidad de tipos en la operacion", token, g);
                resul.tipoVar = Simbolo.TipoVariable.DESCONOCIDO;				
		    }
		    else {
		        resul.tipoVar = Simbolo.TipoVariable.ENTERO;
		        // Si son constantes compruebo valores en rango y posibles errores de division o modulo por 0.
		        // Optimizar ejecutando la operacion
				if(r1.tipoSimb == Simbolo.TipoSimbolo.CONST && r2.tipoSimb == Simbolo.TipoSimbolo.CONST) {
				    resul.tipoSimb = Simbolo.TipoSimbolo.CONST;
				    optimizar = true;
				    if (!miniLeng.rango_enteros(r1.valorEnt) || !miniLeng.rango_enteros(r2.valorEnt)) {
                		miniLeng.error_semantico("Valor fuera de rango", token, g);
                		resul.tipoVar = Simbolo.TipoVariable.DESCONOCIDO;
                	}
                	else { 
	                	switch (op) {
						case SUMA:
					        resul.valorEnt = r1.valorEnt + r2.valorEnt;
							break;
						case RESTA:
					        resul.valorEnt = r1.valorEnt + r2.valorEnt;
						    break;
						default:
							break;
					    }
						resul.nodoAST = new ASTNode("", g.nivel, ASTNode.TipoNodo.CONST);
						resul.nodoAST.setValue(resul.valorEnt);
						resul.nodoAST.setTypeVar(resul.tipoVar);
					}
				}
				else if(r1.tipoVar == Simbolo.TipoVariable.DESCONOCIDO
						|| r2.tipoVar == Simbolo.TipoVariable.DESCONOCIDO)
				{
				  resul.tipoVar = Simbolo.TipoVariable.DESCONOCIDO;
				}
		    }
  	  	}
  	  	if (ok && !optimizar) {
  	  	  if(!anidar){
  	  	  	miniLeng.createSubTreeAST(resul.nodoAST, r1.nodoAST, r2.nodoAST, ASTNode.TipoNodo.OP,op);
  	  	  	aux = resul.nodoAST;
  	  	  	anidar = true;
  	  	  }
  	  	  else{
  	  	    resul.nodoAST = new ASTNode("op", g.nivel);
  	  	  	miniLeng.createSubTreeAST(resul.nodoAST, aux, r2.nodoAST, ASTNode.TipoNodo.OP,op);
			aux = resul.nodoAST;
  	  	  }  	  
  	  	}
	}
	)*
	{
	  if (r2 == null)
	    return r1;
	  else
	    return resul;
	}  
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image, g);
	return null;       
  }
}
/* termino ::= factor (operador multiplicativo factor)* */
RegistroExpr termino(Globals g) : 
{
  RegistroExpr r1 = null, r2=null;
  RegistroExpr resul = new RegistroExpr();
  ASTNode aux = null, ultimo = null;
  Simbolo.TipoOperador op;
  Boolean ok, optimizar = false, anidar = false;
}
{
  try {
    {  resul.nodoAST = new ASTNode("op", g.nivel);  }
    r1 = factor(g)
    ( op = operador_multiplicativo(g)
      r2 = factor(g)
{
  	  // Analisis semantico
  	  // Comprobar que son del mismo tipo MUL/DIV/MOD (entero o desconocido) AND (bool)
  	  // Generacion de codigo
		if ( op == Simbolo.TipoOperador.AND ) {
			ok = validar_tipo(r1.tipoVar, Simbolo.TipoVariable.BOOLEANO, g)
		        && validar_tipo(r2.tipoVar, Simbolo.TipoVariable.BOOLEANO, g);
		    if (!ok) {
                miniLeng.error_semantico("Incompatibilidad de tipos en la operacion", token, g);
                resul.tipoVar = Simbolo.TipoVariable.DESCONOCIDO;				
		    }
		    else {
		        resul.tipoVar = Simbolo.TipoVariable.BOOLEANO;
		      // Si son constantes optimizo realizando la operacion
				if(r1.tipoSimb == Simbolo.TipoSimbolo.CONST && r2.tipoSimb == Simbolo.TipoSimbolo.CONST) {
				    resul.tipoSimb = Simbolo.TipoSimbolo.CONST;
				    optimizar = true;
                	resul.valorBool = r1.valorBool & r2.valorBool;
                	resul.nodoAST = new ASTNode("", g.nivel, ASTNode.TipoNodo.CONST);
                	resul.nodoAST.setValue(((resul.valorBool) ? 1 : 0));
					resul.nodoAST.setTypeVar(Simbolo.TipoVariable.BOOLEANO);
				}
				else if(r1.tipoVar == Simbolo.TipoVariable.DESCONOCIDO
						|| r2.tipoVar == Simbolo.TipoVariable.DESCONOCIDO)
				{
				  resul.tipoVar = Simbolo.TipoVariable.DESCONOCIDO;
				} 
		    }
  	  	}
  	  	else {
		    ok = validar_tipo(r1.tipoVar, Simbolo.TipoVariable.ENTERO, g)
		        && validar_tipo(r2.tipoVar, Simbolo.TipoVariable.ENTERO, g);
		    if (!ok) {
                miniLeng.error_semantico("Incompatibilidad de tipos en la operacion", token, g);
                resul.tipoVar = Simbolo.TipoVariable.DESCONOCIDO;				
		    }
		    else {
		        resul.tipoVar = Simbolo.TipoVariable.ENTERO;
		        // Si son constantes compruebo valores en rango y posibles errores de division o modulo por 0.
		        // Optimizar ejecutando la operacion
				if(r1.tipoSimb == Simbolo.TipoSimbolo.CONST && r2.tipoSimb == Simbolo.TipoSimbolo.CONST) {
				    resul.tipoSimb = Simbolo.TipoSimbolo.CONST;
				    optimizar = true;
				    if (!miniLeng.rango_enteros(r1.valorEnt) || !miniLeng.rango_enteros(r2.valorEnt)) {
                		miniLeng.error_semantico("Valor fuera de rango", token, g);
                		resul.tipoVar = Simbolo.TipoVariable.DESCONOCIDO;
                	}
                	else { 
	                	switch (op) {
						case MUL:
					        resul.valorEnt = r1.valorEnt * r2.valorEnt;
							break;
						case DIV:
					        if ( r2.valorEnt == 0 ) {
					            miniLeng.error_semantico("Division por 0", token, g);
					            resul.tipoVar = Simbolo.TipoVariable.DESCONOCIDO;
					        }
					   		else{
					            resul.valorEnt = r1.valorEnt / r2.valorEnt;
					   		}
						    break;
					    case MOD:
				            if ( r2.valorEnt == 0 ) {
				                miniLeng.error_semantico("Operacion modulo por 0", token, g);
				                resul.tipoVar = Simbolo.TipoVariable.DESCONOCIDO;
				            }
				            else{
				                resul.valorEnt = r1.valorEnt % r2.valorEnt;
				            }
							break;
						default:
							break;
					    }
						resul.nodoAST = new ASTNode("", g.nivel, ASTNode.TipoNodo.CONST);
						resul.nodoAST.setValue(resul.valorEnt);
						resul.nodoAST.setTypeVar(resul.tipoVar);
					}
				}
				else if(r2.tipoSimb == Simbolo.TipoSimbolo.CONST && r2.valorEnt == 0 && op == Simbolo.TipoOperador.DIV ) {
						miniLeng.error_semantico("Division por 0", token, g);
					    resul.tipoVar = Simbolo.TipoVariable.DESCONOCIDO;
				}
				else if (r2.tipoSimb == Simbolo.TipoSimbolo.CONST && r2.valorEnt == 0 && op == Simbolo.TipoOperador.MOD) {
					miniLeng.error_semantico("Operacion modulo por 0", token, g);
				    resul.tipoVar = Simbolo.TipoVariable.DESCONOCIDO;
				}
				else if ( op == Simbolo.TipoOperador.MUL
					&& ( (r1.tipoSimb == Simbolo.TipoSimbolo.CONST && r1.valorEnt == 0) || (r2.tipoSimb == Simbolo.TipoSimbolo.CONST && r2.valorEnt == 0) ) )
				{
				  	optimizar = true;
					resul.nodoAST = new ASTNode("", g.nivel, ASTNode.TipoNodo.CONST);
					resul.nodoAST.setValue(0);
					resul.nodoAST.setTypeVar(resul.tipoVar);
				}
				else if(r1.tipoVar == Simbolo.TipoVariable.DESCONOCIDO
						|| r2.tipoVar == Simbolo.TipoVariable.DESCONOCIDO)
				{
				  resul.tipoVar = Simbolo.TipoVariable.DESCONOCIDO;
				}
		    }
  	  	}
  	  	if (ok && !optimizar) {
  	  	  if(!anidar){
  	  	  	miniLeng.createSubTreeAST(resul.nodoAST, r1.nodoAST, r2.nodoAST, ASTNode.TipoNodo.OP,op);
  	  	  	aux = resul.nodoAST;
  	  	  	anidar = true;
  	  	  }
  	  	  else{
  	  	    resul.nodoAST = new ASTNode("op", g.nivel);
  	  	  	miniLeng.createSubTreeAST(resul.nodoAST, aux, r2.nodoAST, ASTNode.TipoNodo.OP,op);
			aux = resul.nodoAST;
  	  	  }  	  
  	  	}
	}
    )*
    {
	  if (r2 == null)
	    return r1;
	  else
	    return resul;
	}  
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image, g);
	return null;    
  }
}
RegistroExpr factor(Globals g) : 
{
  Token t;
  Simbolo s;
  RegistroExpr r1,resul = new RegistroExpr();
  Simbolo.TipoVariable tipoVar;
}
{
  try { 
    "-" r1 = factor(g)
  {
    // Comprobar si es del tipo ENTERO o DESCONOCIDO
	if ( (r1.tipoVar != Simbolo.TipoVariable.ENTERO)
	     && (r1.tipoVar != Simbolo.TipoVariable.DESCONOCIDO)) {
      miniLeng.error_semantico("Tipo incompatible, se esperaba entero", g);
      resul.tipoVar = Simbolo.TipoVariable.DESCONOCIDO;
    }
    else {
      // TODO: MARCAR NEGADO
      resul.tipoVar = Simbolo.TipoVariable.ENTERO;
      resul.nodoAST = r1.nodoAST;
    }
    return resul;
  }
 |  < tNOT > r1 = factor(g)
 {
    // Comprobar si es del tipo BOOL o DESCONOCIDO
	if ( (r1.tipoVar != Simbolo.TipoVariable.BOOLEANO)
	     && (r1.tipoVar != Simbolo.TipoVariable.DESCONOCIDO)) {
      miniLeng.error_semantico("Tipo incompatible, se esperaba booleano", g);
      resul.tipoVar = Simbolo.TipoVariable.DESCONOCIDO;
    }
    else {
      resul.tipoVar = Simbolo.TipoVariable.BOOLEANO;
      resul.nodoAST = r1.nodoAST;
      resul.nodoAST.setNegar_valor(true);
    }
    return resul;
 }
 |  "(" r1 = expresion(g) ")"
 {
   return r1;
 }
 |  < tENTACAR > "(" r1 = expresion(g) ")"
 {
    // Comprobar si es del tipo ENTERO o DESCONOCIDO
	if ( (r1.tipoVar != Simbolo.TipoVariable.ENTERO)
	     && (r1.tipoVar != Simbolo.TipoVariable.DESCONOCIDO)) {
      miniLeng.error_semantico("La expresion no se puede convertir en un carácter válido", token,  g);
      resul.tipoVar = Simbolo.TipoVariable.DESCONOCIDO;
    }
    else if ( r1.tipoSimb == Simbolo.TipoSimbolo.CONST && (r1.valorEnt > 126 || r1.valorEnt < 1)) {
	  miniLeng.error_semantico("La operacion ENTACAR debe recibir un parámetro del tipo entero comprendido entre 1 y 126", token, g);
    }
    else {
      resul.nodoAST = new ASTNode("entcar", g.nivel, ASTNode.TipoNodo.ENTCAR);
	  resul.nodoAST.setTypeVar(Simbolo.TipoVariable.CADENA);
	  resul.nodoAST.setRight(r1.nodoAST);
      resul.tipoVar = Simbolo.TipoVariable.CHAR;
    }
    return resul;
 }
 |  < tCARAENT > "(" r1 = expresion(g) ")"
 {
    // Comprobar si es del tipo CHAR o DESCONOCIDO
	if ( (r1.tipoVar != Simbolo.TipoVariable.CHAR) && (r1.tipoVar != Simbolo.TipoVariable.CADENA)
	     && (r1.tipoVar != Simbolo.TipoVariable.DESCONOCIDO)) {
      miniLeng.error_semantico("La expresion no se puede convertir en un valor válido", token, g);
      resul.tipoVar = Simbolo.TipoVariable.DESCONOCIDO;
    }
    else {
      resul.tipoVar = Simbolo.TipoVariable.ENTERO;
      resul.nodoAST = r1.nodoAST;
    }
    return resul;
 }
 |  t = < tIDENTIFICADOR >
 {
   // Comprobar si existe en la tabla de simbolos
   if ( (s = g.t.buscar_simbolo(t.image, Simbolo.TipoSimbolo.VAR_PARAM)) == null ) {
   	 // Introducir como desconocido
   	 g.t.introducir_variable(t.image,Simbolo.TipoVariable.DESCONOCIDO,g.nivel,g.dir);
     miniLeng.error_semantico("Identificador desconocido", t, g);
     resul.tipoVar = Simbolo.TipoVariable.DESCONOCIDO;
   }
   else {
     if( (s = g.t.buscar_simbolo(t.image, Simbolo.TipoSimbolo.PARAMETRO)) == null) {
		s = g.t.buscar_simbolo(t.image, Simbolo.TipoSimbolo.VARIABLE);
     }
     resul.tipoVar = s.getVariable();
     resul.clase = (s.getParametro() != null) ? s.getParametro() : Simbolo.ClaseParametro.VAR;
     //resul.clase = s.getParametro();
     resul.nodoAST = new ASTNode(t.image, s.getNivel(), ASTNode.TipoNodo.VAR);
     resul.nodoAST.setDir(s.getDir());
     resul.nodoAST.setTypeParam(s.getParametro());
   }
   return resul;
 }
 |  t = < tCONSTCHAR >
 {
   if(t.image.length() > 3) {
       miniLeng.error_semantico("No se puede utilizar cadenas en expresiones", t, g);
   }
   else { 
	   resul.valorString = t.image;
	   resul.nodoAST = new ASTNode(t.image, g.nivel, ASTNode.TipoNodo.CONST);
	   resul.nodoAST.setTypeVar(Simbolo.TipoVariable.CHAR);
	   resul.nodoAST.setValue((int)(t.image.charAt(1)));
   }
   resul.tipoVar = Simbolo.TipoVariable.CHAR;
   return resul;
 }
  |  t = < tCONSTCAD >
 {
   if(t.image.length() > 3) {
       miniLeng.error_semantico("No se puede utilizar cadenas en expresiones", t, g);
   }
   else { 
	   resul.valorString = t.image;
	   resul.nodoAST = new ASTNode(t.image, g.nivel, ASTNode.TipoNodo.CONST);
	   resul.nodoAST.setTypeVar(Simbolo.TipoVariable.CHAR);
	   resul.nodoAST.setValue((int)(t.image.charAt(1)));
   }
   resul.tipoVar = Simbolo.TipoVariable.CHAR;
   return resul;
 }
 |  t = < tCONSTENTERA >
 {
   resul.valorEnt = Integer.parseInt(t.image);
   resul.tipoVar = Simbolo.TipoVariable.ENTERO;
   resul.tipoSimb = Simbolo.TipoSimbolo.CONST;
   resul.nodoAST = new ASTNode("ent", g.nivel, ASTNode.TipoNodo.CONST);
   resul.nodoAST.setValue(resul.valorEnt);
   resul.nodoAST.setTypeVar(Simbolo.TipoVariable.ENTERO);
   return resul;
 }
 |  < tTRUE >
 {
   resul.valorBool = true;
   resul.tipoVar = Simbolo.TipoVariable.BOOLEANO;
   // Se utiliza 1 como entero para guardar una constante TRUE
   resul.nodoAST = new ASTNode("bool", g.nivel, ASTNode.TipoNodo.CONST);
   resul.nodoAST.setValue(1);
   resul.nodoAST.setTypeVar(Simbolo.TipoVariable.ENTERO);
   return resul;
 }
 |  < tFALSE >
 {
   resul.valorBool = false;
   resul.tipoVar = Simbolo.TipoVariable.BOOLEANO;
   // Se utiliza 0 como entero para guardar una constante FALSE
   resul.nodoAST = new ASTNode("bool",g.nivel, ASTNode.TipoNodo.CONST);
   resul.nodoAST.setValue(0);
   resul.nodoAST.setTypeVar(Simbolo.TipoVariable.ENTERO);
   return resul;
 }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image, g);
	return null;    
  }
}
/***************************************************************************************************
***************************************************************************************************/
/******************************************** Tipo ************************************************/
/* tipo_variables ::= < tENTERO > | < tCARACTER > | < tBOOLEANO > */
Simbolo.TipoVariable tipo_variables(Globals g) :
{}
{
  try {
    < tENTERO >    { return Simbolo.TipoVariable.ENTERO; }
|   < tCARACTER >  { return Simbolo.TipoVariable.CHAR; }
|   < tBOOLEANO >  { return Simbolo.TipoVariable.BOOLEANO; }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image, g);
	return null; 
  }
}
/* clase_parametros ::= < tVAL > | < tREF > */
Simbolo.ClaseParametro clase_parametros(Globals g) :
{}
{
  try {
    < tVAL > { return Simbolo.ClaseParametro.VAL; }
 |  < tREF > { return Simbolo.ClaseParametro.REF; }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image, g);
	return null; 
  }
}
Simbolo.TipoOperador operador_relacional(Globals g) :
{}
{
  try {
    	< tMAYOR >      { return Simbolo.TipoOperador.GT; }
  | 	< tMENOR >      { return Simbolo.TipoOperador.LT; }
  | 	< tIGUAL >      { return Simbolo.TipoOperador.EQ; }
  | 	< tMAI >        { return Simbolo.TipoOperador.GE; }
  | 	< tMEI  >       { return Simbolo.TipoOperador.LE; }
  | 	< tNI >         { return Simbolo.TipoOperador.NE; }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image, g);
	return null; 
  }
}
Simbolo.TipoOperador operador_aditivo(Globals g) :
{}
{
  try {
    "+" 		{ return Simbolo.TipoOperador.SUMA; }
    | "-"	    { return Simbolo.TipoOperador.RESTA; }
    | < tOR >   { return Simbolo.TipoOperador.OR; }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image, g);
	return null; 
  }
}
Simbolo.TipoOperador operador_multiplicativo(Globals g) :
{}
{
  try {
    "*"            { return Simbolo.TipoOperador.MUL; }
    | < tDIV >     { return Simbolo.TipoOperador.DIV; }
    | < tMOD >     { return Simbolo.TipoOperador.MOD; }
    | < tAND >     { return Simbolo.TipoOperador.AND; }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image, g);
	return null; 
  }
}
/***************************************************************************************************
***************************************************************************************************/
/******************************************** Tokens **********************************************/
SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
| "%" : COMMENT 
}
< COMMENT > SKIP :
{
  "\n" : DEFAULT
}
<COMMENT> MORE : {
	<~[]>
}
TOKEN : /*  Reservadas */
{
	< tPROGRAMA : "programa" > 
| 	< tVAR : "var" >
| 	< tAND: "and" >
| 	< tOR: "or" >
| 	< tNOT: "not" >
| 	< tPRINCIPIO : "Principio" > 
| 	< tFIN: "Fin" > 
| 	< tSI: "Si" >
| 	< tENT: "ent" >
| 	< tSI_NO : "Si_no" >
| 	< tFSI: "FSi" >
| 	< tMQ: "Mq" >
| 	< tFMQ: "FMq" >
| 	< tESCRIBIR : "escribir" >
| 	< tLEER: "leer" >
| 	< tMOD: "mod" >
| 	< tDIV: "div" >
| 	< tENTERO: "entero" >
| 	< tBOOLEANO: "booleano" >
| 	< tCARACTER : "caracter" >
| 	< tTRUE: "TRUE" >
| 	< tFALSE: "FALSE" >
| 	< tENTACAR: "entacar" >
| 	< tCARAENT: "caraent" >
| 	< tACCION: "accion" >
| 	< tVAL : "val" >
| 	< tREF: "ref" >
| 	< tMAYOR: ">" >
| 	< tMENOR: "<" >
| 	< tIGUAL: "=" >
| 	< tMAI: ">=" >
| 	< tMEI : "<=" >
| 	< tNI: "<>" >
| 	< tOPAS: ":=" >
}
TOKEN :   /* Digits */
{
  < tCONSTENTERA : (< DIGIT >)+ >
| < tREAL : (< DIGIT >)+ "." (< DIGIT >)+ >
| < #DIGIT : [ "0"-"9" ] >
}
TOKEN : {
 < tIDENTIFICADOR: <LETTER> ((<LETTER> | <DIGIT>)* (["A"-"Z","a"-"z","0"-"9"]) )? >
| < #LETTER: ["A"-"Z","_","a"-"z"] >
| < tCONSTCHAR : "\'"  (~["\'","\\","\n","\r"] |  "\\" ["n","t","b","r","f","\\"])*  "\'" >
| < tCONSTCAD  : "\""  (~["\"","\\","\n","\r"] |  "\\" ["n","t","b","r","f","\\"])*  "\"" >
}
