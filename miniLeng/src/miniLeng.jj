/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options
{
  static = true;
}

PARSER_BEGIN(miniLeng)

import java.io.*;
import miniLeng.Simbolo;
import miniLeng.Tabla_simbolos;
import miniLeng.Globals;
import miniLeng.RegistroExpr;
import miniLeng.ASTNode;
import java.util.ArrayList;

public class miniLeng
{
  
  public static void main(String args []) throws ParseException
  {
    
      BufferedReader new_buffer = new BufferedReader(new InputStreamReader(System.in));
	  String file;
	  miniLeng parser;
	  Globals variables = new Globals();
	  variables.t = new Tabla_simbolos();
	  System.out.println("Ruta y nombre del fichero:");
	 /* 
	  try
	  {
	    file=new_buffer.readLine();
	  }catch(IOException e) {
	    System.out.println("Error al leer la cadena");
	    return;
	  }
	  */
	  //file = "/Users/heru/git/miniLeng-javacc/miniLeng/src/pruebas4.txt";
	  file = "/Users/heru/git/miniLeng/miniLeng-javacc/miniLeng/src/pruebas5.txt";
	  System.out.println(file);
	  
	  try {
	    parser = new miniLeng(new FileInputStream(file));
	  }
	  catch(FileNotFoundException e) {
	    System.out.println("Fallo al leer el fichero");
	    return;
	  }

	  //tabla.inicializar_tabla();
	  try {
	    parser.programa_completo(variables);
	  }
	  catch (Error e) {
	    int linea = token.beginLine;
	    int columna = token.beginColumn;
	    String simbolo = token.image;
	    System.out.println("ERROR LÉXICO (<" + linea + ", " + columna + ">): símbolo no reconocido: <" + simbolo + ">");
	    System.out.println("Oops.");
	    System.out.println(e.getMessage());
	  }

	  int x = 3+2;

  }
  /********** Tratamiento Errores **********************/
  public static void tratarErrorSintactico(int line, int column, String msg_error) {
	System.out.println("ERROR SINTACTICO (<" + line + ", " + column + ">): Simbolo encontrado \"" + msg_error + "\"");
  }

  public static void error_semantico(String msg_error) {
	System.out.println("ERROR SEMANTICO : " + msg_error);
  }
  public static void error_semantico(String msg_error, Token t) {
    int line = t.beginLine;
    int col = t.beginColumn;
    String id = t.image;
	System.out.println("ERROR SEMANTICO (<" + line + ", " + col + ">): " + msg_error + ": \"" + id + "\"");
  }

  public static void warning(String msg_error, int line) {
	System.out.println("WARNING : linea " + line + " -- " + msg_error);
  }
  
  public static boolean comparar_tipos(Simbolo.TipoVariable t1, Simbolo.TipoVariable t2, Simbolo.TipoVariable tipo, int verbose){
    boolean resul = true;
    if ( t1 != tipo && t2 != tipo )
    {
      resul = false;
      if (verbose==1) { 
        miniLeng.error_semantico("linea " + token.beginLine + "  - Los operadorores deben ser " + tipo);
      }      
    }
    return resul;
  }

  public static boolean validar_tipo(Simbolo.TipoVariable t, Simbolo.TipoVariable tipo){
    boolean resul = true;
    if ( t != tipo  && t != Simbolo.TipoVariable.DESCONOCIDO)
    {
        miniLeng.error_semantico("linea " + token.beginLine + "  -  El operador debe ser " + tipo);
        resul=false;
    }
    return resul;
  }

  public static void formarNodoAST(ASTNode root, ASTNode left, ASTNode right, ASTNode.TipoNodo type, Simbolo.TipoOperador op) {
     // Generacion de codigo
     root.setType(type);
     root.setTypeOp(op);
     root.setLeft(left);
     root.setRight(right);
  }
}

  
PARSER_END(miniLeng)


void programa_completo(Globals g):
{}
{
  programa(g) < EOF >
}


/*  programa ::= < tPROGRAMA > <tIDENTIFICADOR > ";"
					declaracion_variables
					declaracion_acciones
					bloque_sentencias             */
void programa(Globals g) : 
{ Token t1; }
{
  try { 
	<tPROGRAMA> t1 = <tIDENTIFICADOR> ";"
	{
	  //TODO: Comprobar que no existe otro programa <TFIN >?
	  g.setDireccionInicial();
	  g.t.introducir_programa(t1.image, g.dir);
	  g.ast.crearAST(t1.image);
	}
	declaracion_variables(g)
	declaracion_acciones(g)
	bloque_sentencias(g)
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.beginLine, token.beginColumn, token.image);
	System.out.println(e.getMessage());    
  }
}


/* declaracion_variables ::= (declaracion ";")* */
void declaracion_variables(Globals g) : 
{}
{
  try { 
    (declaracion(g) ";")*
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());      
  }
}


/* declaracion ::= tipo_variables identificadores */
void declaracion(Globals g) : 
{Simbolo.TipoVariable tipoVar;}
{
  try { 
    tipoVar = tipo_variables(g) identificadores(g, tipoVar)
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());       
  }
}




/* identificadores ::= < tIDENTIFICADOR > ( "," < tIDENTIFICADOR >)* */
void identificadores(Globals g, Simbolo.TipoVariable tipoVar) : 
{ Token t1,t2; Simbolo s; }
{
  try { 
    t1 = < tIDENTIFICADOR >
	{
	  //TODO: Puede ser otro tipo de error
	  s =  g.t.buscar_simbolo(t1.image, g.nivel);
		if ( s != null && s.esVisible() ) 
		    miniLeng.error_semantico("Identificador duplicado", t1);
		else
			g.t.introducir_variable(t1.image, tipoVar, g.nivel, g.dir);
	}
     ( "," t2 = < tIDENTIFICADOR>
	{
	  s =  g.t.buscar_simbolo(t2.image, g.nivel);
		if ( s != null && s.esVisible() ) 
		    miniLeng.error_semantico("Identificador duplicado", t2);
		else 
			g.t.introducir_variable(t2.image, tipoVar, g.nivel, g.dir);
	}	
     )*
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());       
  }
}

/***************************************************************************************************
***************************************************************************************************/
/******************************************** Acciones ********************************************/

/* declaracion_acciones ::= (declaracion_accion)* */
void declaracion_acciones(Globals g) : 
{}
{
  try { 
    ( declaracion_accion(g) )*
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());       
  }
}


/* declaracion_accion ::= cabecera_accion ";"
							declaracion_variables
							declarracion_acciones
							bloque sentencias	*/
void declaracion_accion(Globals g) : 
{}
{
  try { 
    cabecera_accion(g) ";"
	declaracion_variables(g) 
	declaracion_acciones(g) 
	bloque_sentencias(g)
	{
	  //Eliminamos variables del bloque y bajamos un nivel
	  g.t.eliminar_variables(g.nivel);
	  g.t.eliminar_acciones(g.nivel);
	  g.t.ocultar_parametros(g.nivel);
	  g.t.eliminar_parametros_ocultos(g.nivel+1);
	  g.nivel--;
	}
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());  
  }
}

/* cabecera_accion ::= < tACCION > < tIDENTIFICADOR > (parametros_formales)? */
void cabecera_accion(Globals g) : 
{
  Token t1;
  Simbolo s = null;
 }
{
  try { 
    < tACCION >
    t1 = < tIDENTIFICADOR >
	{
	  //Introduce en la tabla la accion
	  s = g.t.introducir_accion(t1.image,g.nivel,g.dir);
	  if ( s == null ) {
		// Existe el simbolo en el mismo nivel
		miniLeng.error_semantico("Identificador duplicado", t1);
	  }
	  g.nivel++;
	}

   (parametros_formales(g, s) )?
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());    
  }
}

/* parametros_formales ::= ( "(" parametros ")")? */
void parametros_formales(Globals g, Simbolo s) : 
{}
{
  try { 
	 "(" (parametros(g, s))? ")"
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());  
  }
}

/* lista_parametros ::= identificadores (";" paraemtros)? */
void lista_parametros(Globals g, Simbolo s, Simbolo.TipoVariable tipoVar, Simbolo.ClaseParametro tipoParam) : 
{Token t1, t2;}
{
  try { 
    t1 = < tIDENTIFICADOR >
	{
	    s.add_param();
	  //TODO: Puede ser otro tipo de error
		if ( g.t.buscar_simbolo(t1.image, g.nivel) != null) 
		    miniLeng.error_semantico("Identificador duplicado", t1);
		else { 
			g.t.introducir_parametro(t1.image, tipoVar, tipoParam, g.nivel, g.dir);
			if ( s != null && s.esAccion())
				s.introducir_parametro(t1.image, tipoVar, tipoParam, g.nivel);
		}
	}
     ( "," t2 = < tIDENTIFICADOR >
	{
	  	s.add_param();
		if ( g.t.buscar_simbolo(t2.image, g.nivel) != null) 
		    miniLeng.error_semantico("Identificador duplicado", t2);
		else { 
			g.t.introducir_parametro(t2.image, tipoVar, tipoParam, g.nivel, g.dir);
			if ( s != null && s.esAccion())
				s.introducir_parametro(t2.image, tipoVar, tipoParam, g.nivel);
		}
	}	
     )* ( ";" parametros(g, s))?
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());    
  }
}

/* parametros ::= clase_parametros tipo_variables lista_parametros */
void parametros(Globals g, Simbolo s) : 
{
  Simbolo.TipoVariable tipoVar;
  Simbolo.ClaseParametro tipoParam;
 }
{
  try { 
    tipoParam = clase_parametros(g) tipoVar = tipo_variables(g) lista_parametros(g, s, tipoVar, tipoParam)
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());     
  }
}




/***************************************************************************************************
***************************************************************************************************/
/******************************************* Sentencias *******************************************/


/* bloque_sentencias ::= < tPRINCIPIO > lista_sentencias < tFIN > */
void bloque_sentencias(Globals g) : 
{}
{
  try { 
    < tPRINCIPIO > lista_sentencias(g) < tFIN >
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());      
  }
}


/* lista_sentencias ::= ( sentencia )* */
void lista_sentencias(Globals g) : 
{}
{
  try { 
    ( sentencia(g) )*
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());    
  }
}

/* sentencia ::= asignacion | invoacion_accion | mientras_que | leer | escribir | selecion */
void sentencia(Globals g) : 
{Token t;}
{
  try { 
	  t = < tIDENTIFICADOR >
	 [ 
		   asignacion(g, t)
		 | invocacion_accion(g, t)
	 ]
	| mientras_que(g)
	| leer(g) ";"
	| escribir(g) ";"
	| seleccion(g)
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());     
  }
}

/* asignacion ::= < tOPAS > expresion ";" */
void asignacion(Globals g, Token t) :
{
 RegistroExpr r;
 Simbolo s;
 Simbolo.TipoVariable tipo;
 Boolean ok = true;
 ASTNode node;
}
{
  try { 
     < tOPAS >
     {
        //TODO: Realizar mas comprobaciones
        // Comprobar que existe el identificador
        s = g.t.buscar_simbolo(t.image, g.nivel);
        if ( s == null ){
            miniLeng.error_semantico("Identificador desconocido en la parte izquierda de la asignacion", t);
            tipo = Simbolo.TipoVariable.DESCONOCIDO;
            ok = false;
        }
        else if (s.esParametro() && s.esValor()){
            miniLeng.error_semantico("No se permote realizar una asignacion a un parametro pasado como valor", t);
            tipo = Simbolo.TipoVariable.DESCONOCIDO;
            ok = false;
        }
        else{
            tipo = s.getVariable();
        }
     }
     r = expresion(g) ";"
     {
        //TODO: Realizar mas comprobaciones
        if ( ok && (r.tipo != tipo) && !comparar_tipos(r.tipo, tipo, Simbolo.TipoVariable.DESCONOCIDO,0))
        {
            miniLeng.error_semantico("Tipos incompatibles en la asignacion", t);
        }
        else {
            // Insertar nodo ASG en AST (Left: variable, Right: expresion)
			node = g.ast.insertar_inst(t.image,ASTNode.TipoNodo.ASG);
			node.setLeft(new ASTNode(t.image));
			node.setRight(r.nodoAST);
        }
     }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());  
  }
}

/* invocacion_accion ::= argumentos ";" */
void invocacion_accion(Globals g, Token t) :
{ Simbolo s; boolean ok = false; }
{
  try { 
     {
        //TODO: Realizar mas comprobaciones
        // Comprobar que existe el identificador
        s = g.t.buscar_simbolo(t.image, g.nivel);
        if ( s == null ){
            miniLeng.error_semantico("Identificador desconocido en la llamada a la accion", t);
        }
        else if (!s.esAccion()){
            miniLeng.error_semantico("No se puede realizar una llamda a una accion sobre un parametro", t);
        }
     }
	 (argumentos(g, s) { ok=true; })? ";"
	 {
		// Compruebo los parametros de la invocacción en caso de llamarse sin parametros
      	if(!ok && s!= null && s.getNum_params() != 0) {
        	miniLeng.error_semantico("linea " + token.beginLine + "  -  Se esperaban " + s.getNum_params() + " parámetros al invocar a la accion " + s.getNombre());
    	}
     }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());      
  }
}

/* mientras_que ::= < tMQ > expresion lista_sentencias < tFMQ > */
void mientras_que(Globals g) :
{ RegistroExpr r; boolean ok; }
{
  try { 
    < tMQ > r = expresion(g)
     {
        //TODO: Comprobar codigo muerto
        ok = validar_tipo(r.tipo, Simbolo.TipoVariable.BOOLEANO);
        if ( ok && r.valorBool == true ) {
			miniLeng.warning("Generacion de código muerto", token.beginLine);
		}
     }
    lista_sentencias(g) < tFMQ >
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());    
  }
}

/* seleccion ::= < tSI > expresion < tENT > lista_sentencias ( < tSI_NO > lista_sentencias )* < tFSI > */
void seleccion(Globals g) :
{  RegistroExpr r; boolean ok; }
{
  try { 
	 < tSI > r = expresion(g)
     {
        //TODO: Comprobar codigo muerto
        ok=validar_tipo(r.tipo, Simbolo.TipoVariable.BOOLEANO);
     }
	< tENT >
	lista_sentencias(g)
	(< tSI_NO >
	{
		// Comprobar que la sentencia no sea true y genere codigo muerto
		if ( ok && r.valorBool == true ) {
			miniLeng.warning("Generacion de código muerto", token.beginLine);
		}
	}
	lista_sentencias(g))*
	< tFSI >
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage()); 
  }
}

/* leer ::= < tLEER > "(" lista_asinables ")" */
void leer(Globals g) :
{}
{
  try { 
   <tLEER> "(" lista_asignables(g) ")"
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());    
  }
}

/* escribir ::= < tESCRIBIR > "(" lista_escribibles ")" */
void escribir(Globals g) :
{}
{
  try { 
   <tESCRIBIR> "(" lista_escribibles(g) ")"
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());     
  }
}

/* lista_asinables ::= identificadores */
void lista_asignables(Globals g) :
{}
{
  try { 
  	< tIDENTIFICADOR> ( "," < tIDENTIFICADOR> )*
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());      
  }
}

/* lista_escribibles ::= (< tCONSTCAD > | < tCONSTCHAR >) ( "," (< tIDENTIFICADOR > | < tENTACAR >"("expresion")"))* */
void lista_escribibles(Globals g) : 
{  RegistroExpr r; }
{
  try { 
  (< tCONSTCAD > | < tCONSTCHAR >) ( "," (< tIDENTIFICADOR >  |  < tENTACAR > "(" r = expresion(g) ")" ) )*
  }
  catch (Exception e) {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());     
  }
}



/* argumentos ::= ( "(" lista_expresiones ")" )? */
void argumentos(Globals g, Simbolo s) : 
{boolean ok=false;}
{
  try { 
    "(" (lista_expresiones(g, s) { ok=true; })? ")"
    {
		// Compruebo los parametros de la invocacción en caso de llamarse sin parametros
      	if(!ok && s != null && s.getNum_params() != 0) {
        	miniLeng.error_semantico("linea " + token.beginLine + "  -  Se esperaban " + s.getNum_params() + " parámetros al invocar a la accion " + s.getNombre());	
    	}
    }
    
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());    
  }
}

/* lista_expresiones ::= expresion ( "," expresion)* */
void lista_expresiones(Globals g, Simbolo s) : 
{
  RegistroExpr r;
  int num_params = 0;
  ArrayList<RegistroExpr> params = new ArrayList<RegistroExpr>();
}
{
  try { 
    r = expresion(g) { num_params++; params.add(r); }
    ( "," r = expresion(g) { num_params++; params.add(r);  })*
    {
		// Comprobar que los parametros de llamada a la funcion coindicen con los de la tabla
		if (s.getNum_params() != num_params) {
			miniLeng.error_semantico("El número de parámetros de llamada a la función " + s.getNombre() + " no coindice");
		}
		else{
			// Comprobar cada tipo
			for(Simbolo accion_param : s.getLista_simbolos()) {

			  	r = params.get(0);
			  	if (r.clase == Simbolo.ClaseParametro.VAL && accion_param.esValor() ) {
			  	  miniLeng.error_semantico("No se puede pasar un parámetro por valor como referencia en la invocación a la accion");
			  	}
				if(!miniLeng.validar_tipo(r.tipo, accion_param.getVariable())) {
				  break;
				}
				params.remove(0);
			}
		}

    }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());     
  }
}

/* expresion ::= expresion_simple | (operador_relacional expresion_simple)* */
RegistroExpr expresion(Globals g) : 
{ RegistroExpr r1,r2 = null;
  Simbolo.TipoOperador op;
  RegistroExpr resul = new RegistroExpr();
  Boolean ok;
}
{
  try { 
	r1 = expresion_simple(g)
	(op =operador_relacional(g)
	 r2 = expresion_simple(g)
	{
		if((r1.tipo != r2.tipo) && !comparar_tipos(r1.tipo,r2.tipo, Simbolo.TipoVariable.DESCONOCIDO,0)) {
		    miniLeng.error_semantico("Los operandos deben ser del mismo tipo");
		    resul.tipo = Simbolo.TipoVariable.DESCONOCIDO;
		}
		else {
		    resul.tipo = Simbolo.TipoVariable.BOOLEANO;
		    switch (r1.tipo) {
				case ENTERO:
					ok = validar_tipo(r2.tipo, Simbolo.TipoVariable.ENTERO);
					if ( !ok )
						resul.tipo = Simbolo.TipoVariable.DESCONOCIDO;
					else {
					    switch (op) {
                   			case GT:
                        		resul.valorBool = r1.valorEnt > r2.valorEnt;
            		    		break;
            	    		case LT:
                        		resul.valorBool = r1.valorEnt < r2.valorEnt;
            		    		break;
            	    		case GE:
                        		resul.valorBool = r1.valorEnt >= r2.valorEnt;
            					break;
            	    		case LE:
                        		resul.valorBool = r1.valorEnt <= r2.valorEnt;
            					break;
             	    		case EQ:
                         		resul.valorBool = r1.valorEnt == r2.valorEnt;
             					break;
            	    		case NE:
                        		resul.valorBool = r1.valorEnt != r2.valorEnt;
            					break;
            	    		default:
            		    		break;
                		}
              		}
					break;
				case CADENA:
					ok = validar_tipo(r2.tipo, Simbolo.TipoVariable.CADENA);
					if ( !ok )
						resul.tipo = Simbolo.TipoVariable.DESCONOCIDO;
					else {
					    switch (op) {
             	    		case EQ:
                         		resul.valorBool = r1.valorString.equals(r2.valorString);
             					break;
            	    		case NE:
                        		resul.valorBool = !r1.valorString.equals(r2.valorString);
            					break;
            	    		default:
            	    		    miniLeng.error_semantico("No se puede utilizar el operador " + op + " sobre una cadena");
            		    		break;
                		}
              		}
					break;
				case BOOLEANO:
					ok = validar_tipo(r2.tipo, Simbolo.TipoVariable.BOOLEANO);
					if ( !ok )
						resul.tipo = Simbolo.TipoVariable.DESCONOCIDO;
					else {
					    switch (op) {
             	    		case EQ:
                         		resul.valorBool = r1.valorBool == r2.valorBool;
             					break;
            	    		case NE:
                        		resul.valorBool = r1.valorBool != r2.valorBool;
            					break;
            	    		default:
            	    		    miniLeng.error_semantico("No se puede utilizar la operador " + op + " sobre un booleano");
            		    		break;
                		}
              		}				
					break;
				default: // DESCONOCIDO
					break;
		    }
		}
	}
	)*
	{
	  if (r2 == null)
	    return r1;
	  else
	    return resul;
	}
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());       
  }
}

/* expresion_simple ::= termino (operador_aditivo termino)* */
RegistroExpr expresion_simple(Globals g) : 
{
  RegistroExpr r1, r2=null;
  RegistroExpr resul = new RegistroExpr();
  Simbolo.TipoOperador op;
  Boolean ok;
}
{
  try { 
	r1 = termino(g)
	( op = operador_aditivo(g)
	  r2 = termino(g)
	{
	  ok = true;
	  //TODO: Comproboar overflow/underflow
	  switch (op) {
		case SUMA:
		    ok = validar_tipo(r1.tipo, Simbolo.TipoVariable.ENTERO)
		        && validar_tipo(r2.tipo, Simbolo.TipoVariable.ENTERO);
		    if ( ok && comparar_tipos(r1.tipo,r2.tipo,Simbolo.TipoVariable.ENTERO,1))
            {
                resul.tipo = Simbolo.TipoVariable.ENTERO;
                resul.valorEnt = r1.valorEnt + r2.valorEnt;
            }
            else {
                resul.tipo = Simbolo.TipoVariable.DESCONOCIDO;
            }
			break;
		case RESTA:
		    ok = validar_tipo(r1.tipo, Simbolo.TipoVariable.ENTERO)
		        && validar_tipo(r2.tipo, Simbolo.TipoVariable.ENTERO);
		    if ( ok && comparar_tipos(r1.tipo,r2.tipo,Simbolo.TipoVariable.ENTERO,1))
            {
                resul.tipo = Simbolo.TipoVariable.ENTERO;
                resul.valorEnt = r1.valorEnt - r2.valorEnt;
            }
            else {
                resul.tipo = Simbolo.TipoVariable.DESCONOCIDO;
            }
			break;
		case OR:
		    ok = validar_tipo(r1.tipo, Simbolo.TipoVariable.BOOLEANO)
		        && validar_tipo(r2.tipo, Simbolo.TipoVariable.BOOLEANO);
		    if ( ok && comparar_tipos(r1.tipo,r2.tipo,Simbolo.TipoVariable.BOOLEANO,1))
            {
                resul.tipo = Simbolo.TipoVariable.BOOLEANO;
                resul.valorBool = r1.valorBool | r2.valorBool;
            }
            else {
                resul.tipo = Simbolo.TipoVariable.DESCONOCIDO;
            }
			break;
		default:
			break;
	   }
	   // Generación de código
	   resul.nodoAST = new ASTNode();
       miniLeng.formarNodoAST(resul.nodoAST, r1.nodoAST, r2.nodoAST, ASTNode.TipoNodo.OP,op);
	}
	)*
	{
	  if (r2 == null)
	    return r1;
	  else
	    return resul;
	}  
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());      
  }
}


/* termino ::= factor (operador multiplicativo factor)* */
RegistroExpr termino(Globals g) : 
{
  RegistroExpr r1, r2=null;
  RegistroExpr resul = new RegistroExpr();
  Simbolo.TipoOperador op;
  Boolean ok;

}
{
  try { 
    r1 = factor(g)
    ( op = operador_multiplicativo(g)
      r2 = factor(g)
{
	  //TODO: Comproboar overflow/underflow
	  switch (op) {
		case MUL:
		    ok = validar_tipo(r1.tipo, Simbolo.TipoVariable.ENTERO)
		        && validar_tipo(r2.tipo, Simbolo.TipoVariable.ENTERO);
		    if ( ok && comparar_tipos(r1.tipo,r2.tipo,Simbolo.TipoVariable.ENTERO,1))
            {
                resul.tipo = Simbolo.TipoVariable.ENTERO;
                resul.valorEnt = r1.valorEnt * r2.valorEnt;
            }
            else {
                resul.tipo = Simbolo.TipoVariable.DESCONOCIDO;
            }
			break;
		case DIV:
		    ok = validar_tipo(r1.tipo, Simbolo.TipoVariable.ENTERO)
		        && validar_tipo(r2.tipo, Simbolo.TipoVariable.ENTERO);
		    //TODO: COMPROBAR DIVISION POR 0
		    if ( ok && comparar_tipos(r1.tipo,r2.tipo,Simbolo.TipoVariable.ENTERO,1))
            {
                if ( r2.valorEnt == 0 ) {
                    miniLeng.error_semantico("Division por 0", token);
                    resul.tipo = Simbolo.TipoVariable.DESCONOCIDO;
                }
                else{
                    resul.tipo = Simbolo.TipoVariable.ENTERO;
                    resul.valorEnt = r1.valorEnt / r2.valorEnt;
                }
            }
            else {
                resul.tipo = Simbolo.TipoVariable.DESCONOCIDO;
            }
			break;
		case MOD:
		    ok = validar_tipo(r1.tipo, Simbolo.TipoVariable.ENTERO)
		        && validar_tipo(r2.tipo, Simbolo.TipoVariable.ENTERO);
            //TODO: COMPROBAR MOD POR 0
		    if ( ok && comparar_tipos(r1.tipo,r2.tipo,Simbolo.TipoVariable.ENTERO,1))
            {
                if ( r2.valorEnt == 0 ) {
                    miniLeng.error_semantico("Operacion modulo por 0");
                    resul.tipo = Simbolo.TipoVariable.DESCONOCIDO;
                }
                else{
                    resul.tipo = Simbolo.TipoVariable.ENTERO;
                    resul.valorEnt = r1.valorEnt / r2.valorEnt;
                }
            }
            else {
                resul.tipo = Simbolo.TipoVariable.DESCONOCIDO;
            }
			break;
		case AND:
		    ok = validar_tipo(r1.tipo, Simbolo.TipoVariable.BOOLEANO)
		        && validar_tipo(r2.tipo, Simbolo.TipoVariable.BOOLEANO);
		    if ( ok && comparar_tipos(r1.tipo,r2.tipo,Simbolo.TipoVariable.BOOLEANO,1))
            {
                resul.tipo = Simbolo.TipoVariable.BOOLEANO;
                resul.valorBool = r1.valorBool & r2.valorBool;
            }
            else {
                resul.tipo = Simbolo.TipoVariable.DESCONOCIDO;
            }
			break;
		default:
			break;
	   }
	   
       // Generacion de codigo
       resul.nodoAST = new ASTNode();
       miniLeng.formarNodoAST(resul.nodoAST, r1.nodoAST, r2.nodoAST, ASTNode.TipoNodo.OP,op);
	}

    )*
    {
	  if (r2 == null)
	    return r1;
	  else
	    return resul;
	}  
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());   
  }
}


RegistroExpr factor(Globals g) : 
{
  Token t;
  Simbolo s;
  RegistroExpr r1,resul = new RegistroExpr();
  Simbolo.TipoVariable tipoVar;
}
{
  try { 
    "-" r1 = factor(g)
  {	
	if ( (r1.tipo != Simbolo.TipoVariable.ENTERO)
	     && (r1.tipo != Simbolo.TipoVariable.DESCONOCIDO)) {
      miniLeng.error_semantico("Tipo incompatible, se esperaba entero");
      resul.tipo = Simbolo.TipoVariable.DESCONOCIDO;
    }
    else {
      resul.tipo = Simbolo.TipoVariable.ENTERO;
    }
    return resul;
  }
 |  < tNOT > r1 = factor(g)
 {
	if ( (r1.tipo != Simbolo.TipoVariable.BOOLEANO)
	     && (r1.tipo != Simbolo.TipoVariable.DESCONOCIDO)) {
      miniLeng.error_semantico("Tipo incompatible, se esperaba booleano");
      resul.tipo = Simbolo.TipoVariable.DESCONOCIDO;
    }
    else {
      resul.tipo = Simbolo.TipoVariable.BOOLEANO;
    }
    return resul;
 }
 |  "(" r1 = expresion(g) ")"
 {
   return r1;
 }
 |  < tENTACAR > "(" r1 = expresion(g) ")"
 {
	if ( (r1.tipo != Simbolo.TipoVariable.ENTERO)
	     && (r1.tipo != Simbolo.TipoVariable.DESCONOCIDO)) {
      miniLeng.error_semantico("La expresion no se puede convertir en un carácter válido");
      resul.tipo = Simbolo.TipoVariable.DESCONOCIDO;
    }
    else {
      resul.tipo = Simbolo.TipoVariable.CHAR;
    }
    return resul;
 }
 |  < tCARAENT > "(" r1 = expresion(g) ")"
 {
	if ( (r1.tipo != Simbolo.TipoVariable.CHAR)
	     && (r1.tipo != Simbolo.TipoVariable.DESCONOCIDO)) {
      miniLeng.error_semantico("La expresion no se puede convertir en un valor válido");
      resul.tipo = Simbolo.TipoVariable.DESCONOCIDO;
    }
    else {
      resul.tipo = Simbolo.TipoVariable.CHAR;
    }
    return resul;
 }
 |  t = < tIDENTIFICADOR >
 {
   s = g.t.buscar_simbolo(t.image,g.nivel);
   if ( s == null ) {
     miniLeng.error_semantico("Identificador desconocido", t);
     resul.tipo = Simbolo.TipoVariable.DESCONOCIDO;
   }
   else {
     resul.tipo = s.getVariable();
     resul.clase = s.getParametro();
   }
   return resul;
 }
 |  t = < tCONSTCHAR >
 {
   resul.valorString = t.image;
   resul.tipo = Simbolo.TipoVariable.CHAR;
   return resul;
 }
 |  t = < tCONSTCAD >
 {
   resul.valorString = t.image;
   resul.tipo = Simbolo.TipoVariable.CADENA;
   return resul;
 }
 |  t = < tCONSTENTERA >
 {
   resul.valorEnt = Integer.parseInt(t.image);
   resul.tipo = Simbolo.TipoVariable.ENTERO;
   resul.nodoAST = new ASTNode(resul.valorEnt);
   return resul;
 }
 |  < tTRUE >
 {
   resul.valorBool = true;
   resul.tipo = Simbolo.TipoVariable.BOOLEANO;
   return resul;
 }
 |  < tFALSE >
 {
   resul.valorBool = false;
   resul.tipo = Simbolo.TipoVariable.BOOLEANO;
   return resul;
 }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());   
  }
}



/***************************************************************************************************
***************************************************************************************************/
/******************************************** Tipo ************************************************/

/* tipo_variables ::= < tENTERO > | < tCARACTER > | < tBOOLEANO > */
Simbolo.TipoVariable tipo_variables(Globals g) :
{}
{
  try {
    < tENTERO >    { return Simbolo.TipoVariable.ENTERO; }
|   < tCARACTER >  { return Simbolo.TipoVariable.CADENA; }
|   < tBOOLEANO >  { return Simbolo.TipoVariable.BOOLEANO; }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());
  }
}

/* clase_parametros ::= < tVAL > | < tREF > */
Simbolo.ClaseParametro clase_parametros(Globals g) :
{}
{
  try {
    < tVAL > { return Simbolo.ClaseParametro.VAL; }
 |  < tREF > { return Simbolo.ClaseParametro.REF; }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());
  }
}


Simbolo.TipoOperador operador_relacional(Globals g) :
{}
{
  try {
    	< tMAYOR >      { return Simbolo.TipoOperador.GT; }
  | 	< tMENOR >      { return Simbolo.TipoOperador.LT; }
  | 	< tIGUAL >      { return Simbolo.TipoOperador.EQ; }
  | 	< tMAI >        { return Simbolo.TipoOperador.GE; }
  | 	< tMEI  >       { return Simbolo.TipoOperador.LE; }
  | 	< tNI >         { return Simbolo.TipoOperador.NE; }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());
  }
}


Simbolo.TipoOperador operador_aditivo(Globals g) :
{}
{
  try {
    "+" 		{ return Simbolo.TipoOperador.SUMA; }
    | "-"	    { return Simbolo.TipoOperador.RESTA; }
    | < tOR >   { return Simbolo.TipoOperador.OR; }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());
  }
}

Simbolo.TipoOperador operador_multiplicativo(Globals g) :
{}
{
  try {
    "*"            { return Simbolo.TipoOperador.MUL; }
    | < tDIV >     { return Simbolo.TipoOperador.DIV; }
    | < tMOD >     { return Simbolo.TipoOperador.MOD; }
    | < tAND >     { return Simbolo.TipoOperador.AND; }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());
  }
}



/***************************************************************************************************
***************************************************************************************************/
/******************************************** Tokens **********************************************/

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
| "%" : COMMENT 
}

< COMMENT > SKIP :
{
  "\n" : DEFAULT
}

<COMMENT> MORE : {
	<~[]>
}

TOKEN : /*  Reservadas */
{
	< tPROGRAMA : "programa" > 
| 	< tVAR : "var" >
| 	< tAND: "and" >
| 	< tOR: "or" >
| 	< tNOT: "not" >
| 	< tPRINCIPIO : "principio" > 
| 	< tFIN: "fin" > 
| 	< tSI: "si" >
| 	< tENT: "ent" >
| 	< tSI_NO : "si_no" >
| 	< tFSI: "fsi" >
| 	< tMQ: "mq" >
| 	< tFMQ: "fmq" >
| 	< tESCRIBIR : "escribir" >
| 	< tLEER: "leer" >
| 	< tMOD: "mod" >
| 	< tDIV: "div" >
| 	< tENTERO: "entero" >
| 	< tBOOLEANO: "booleano" >
| 	< tCARACTER : "caracter" >
| 	< tTRUE: "true" >
| 	< tFALSE: "false" >
| 	< tENTACAR: "entacar" >
| 	< tCARAENT: "caraent" >
| 	< tACCION: "accion" >
| 	< tVAL : "val" >
| 	< tREF: "ref" >
| 	< tMAYOR: ">" >
| 	< tMENOR: "<" >
| 	< tIGUAL: "=" >
| 	< tMAI: ">=" >
| 	< tMEI : "<=" >
| 	< tNI: "<>" >
| 	< tOPAS: ":=" >
}

TOKEN :   /* Digits */
{
  < tCONSTENTERA : (< DIGIT >)+ >
| < tREAL : (< DIGIT >)+ "." (< DIGIT >)+ >
| < #DIGIT : [ "0"-"9" ] >
}


TOKEN : {
 < tIDENTIFICADOR: <LETTER> ((<LETTER> | <DIGIT>)* (["A"-"Z","a"-"z","0"-"9"]) )? >
| < #LETTER: ["A"-"Z","_","a"-"z"] >
| < tCONSTCHAR : "\'"  (~["\'","\\","\n","\r"] |  "\\" ["n","t","b","r","f","\\","\'","\""])*  "\'" >
| < tCONSTCAD  : "\""  (~["\'","\\","\n","\r"] |  "\\" ["n","t","b","r","f","\\","\'","\""])*  "\"" >
}


