/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options
{
  static = true;
}

PARSER_BEGIN(miniLeng)

import java.io.*;
import miniLeng.Simbolo;
import miniLeng.Tabla_simbolos;
import miniLeng.Globals;
import miniLeng.RegistroExpr;
import miniLeng.ASTNode;
import miniLeng.GeneradorCodigo;
import java.util.ArrayList;

public class miniLeng
{
  
  public static void main(String args []) throws ParseException
  {
    
      BufferedReader new_buffer = new BufferedReader(new InputStreamReader(System.in));
	  String file;
	  miniLeng parser;
	  Globals variables = new Globals();
	  variables.t = new Tabla_simbolos();
	  System.out.println("Ruta y nombre del fichero:");
	 /* 
	  try
	  {
	    file=new_buffer.readLine();
	  }catch(IOException e) {
	    System.out.println("Error al leer la cadena");
	    return;
	  }
	  */
	  //file = "/Users/heru/git/miniLeng-javacc/miniLeng/src/pruebas4.txt";
	  file = "/Users/heru/git/miniLeng/miniLeng-javacc/miniLeng/src/pruebas5.txt";
	  System.out.println(file);
	  
	  try {
	    parser = new miniLeng(new FileInputStream(file));
	  }
	  catch(FileNotFoundException e) {
	    System.out.println("Fallo al leer el fichero");
	    return;
	  }

	  //tabla.inicializar_tabla();
	  try {
	    parser.programa_completo(variables);
	  }
	  catch (Error e) {
	    int linea = token.beginLine;
	    int columna = token.beginColumn;
	    String simbolo = token.image;
	    System.out.println("ERROR LÉXICO (<" + linea + ", " + columna + ">): símbolo no reconocido: <" + simbolo + ">");
	    System.out.println("Oops.");
	    System.out.println(e.getMessage());
	  }

  }
  /********** Tratamiento Errores **********************/
  public static void tratarErrorSintactico(int line, int column, String msg_error) {
	System.out.println("ERROR SINTACTICO (<" + line + ", " + column + ">): Simbolo encontrado \"" + msg_error + "\"");
  }

  public static void error_semantico(String msg_error) {
	System.out.println("ERROR SEMANTICO : " + msg_error);
  }
  public static void error_semantico(String msg_error, Token t) {
    int line = t.beginLine;
    int col = t.beginColumn;
    String id = t.image;
	System.out.println("ERROR SEMANTICO (<" + line + ", " + col + ">): " + msg_error + ": \"" + id + "\"");
  }

  public static void warning(String msg_error, int line) {
	System.out.println("WARNING : linea " + line + " -- " + msg_error);
  }
  
  public static boolean comparar_tipos(Simbolo.TipoVariable t1, Simbolo.TipoVariable t2, Simbolo.TipoVariable tipo, int verbose){
    boolean resul = true;
    if ( t1 != tipo && t2 != tipo )
    {
      resul = false;
      if (verbose==1) { 
        miniLeng.error_semantico("linea " + token.beginLine + "  - Los operadorores deben ser " + tipo);
      }      
    }
    return resul;
  }

  public static boolean validar_tipo(Simbolo.TipoVariable t, Simbolo.TipoVariable tipo){
    boolean resul = true;
    if ( t != tipo  && t != Simbolo.TipoVariable.DESCONOCIDO)
    {
        miniLeng.error_semantico("linea " + token.beginLine + "  -  El operador debe ser " + tipo);
        resul=false;
    }
    return resul;
  }

  public static void createSubTreeAST(ASTNode root, ASTNode left, ASTNode right, ASTNode.TipoNodo type, Simbolo.TipoOperador op) {
     // Generacion de codigo
     root.setType(type);
     root.setTypeOp(op);
     root.setLeft(left);
     root.setRight(right);
  }
}

  
PARSER_END(miniLeng)


void programa_completo(Globals g):
{}
{
  programa(g) < EOF >
}

/*  programa ::= < tPROGRAMA > <tIDENTIFICADOR > ";"
					declaracion_variables
					declaracion_acciones
					bloque_sentencias             */
void programa(Globals g) : 
{ Token t1;
  ASTNode acciones = null, sentencias = null;
}
{
  try { 
	<tPROGRAMA> t1 = <tIDENTIFICADOR> ";"
	{
	  //TODO: Comprobar que no existe otro programa <TFIN >?
	  g.setDireccionInicial();
	}
	declaracion_variables(g)
	acciones = declaracion_acciones(g)
	sentencias = bloque_sentencias(g)
	{
	    String etiqueta;
	    GeneradorCodigo codigo = new GeneradorCodigo(t1.image);

	
	    // Generar código del incio del programa
	    etiqueta = codigo.nueva_etiqueta();
	    codigo.escribir(";Programa " + t1.image + ".");
	    codigo.escribir("\tENP " + etiqueta);

		// Generar código de las acciones
		codigo.escribir("\n;Acciones");
		codigo.escribir(acciones);

	    // Generar código del programa principal		
	    codigo.escribir("\n;Comienzo del programa " + t1.image + ".\n");
	    codigo.escribir(etiqueta + ":");	    
		codigo.escribir(sentencias);

		// Fin del programa
	    codigo.escribir("\n;Fin de programa " + t1.image + ".\n");
	    codigo.escribir("\tLVP");
	    codigo.cerrar();		
	}
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.beginLine, token.beginColumn, token.image);
	System.out.println(e.getMessage());    
  }
}

/* declaracion_variables ::= (declaracion ";")* */
void declaracion_variables(Globals g) : 
{}
{
  try { 
    (declaracion(g) ";")*
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());      
  }
}

/* declaracion ::= tipo_variables identificadores */
void declaracion(Globals g) : 
{Simbolo.TipoVariable tipoVar;}
{
  try { 
    tipoVar = tipo_variables(g) identificadores(g, tipoVar)
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());       
  }
}

/* identificadores ::= < tIDENTIFICADOR > ( "," < tIDENTIFICADOR >)* */
void identificadores(Globals g, Simbolo.TipoVariable tipoVar) : 
{ Token t1,t2; Simbolo s; }
{
  try { 
    t1 = < tIDENTIFICADOR >
	{
	  //TODO: Puede ser otro tipo de error
	  s =  g.t.buscar_simbolo(t1.image, g.nivel);
		if ( s != null && s.esVisible() ) 
		    miniLeng.error_semantico("Identificador duplicado", t1);
		else { 
			g.t.introducir_variable(t1.image, tipoVar, g.nivel, g.dir);
			g.dir++;
		}
	}
     ( "," t2 = < tIDENTIFICADOR>
	{
	  s =  g.t.buscar_simbolo(t2.image, g.nivel);
		if ( s != null && s.esVisible() ) 
		    miniLeng.error_semantico("Identificador duplicado", t2);
		else { 
			g.t.introducir_variable(t2.image, tipoVar, g.nivel, g.dir);
			g.dir++;
		}
	}	
     )*
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());       
  }
}

/***************************************************************************************************
***************************************************************************************************/
/******************************************** Acciones ********************************************/

/* declaracion_acciones ::= (declaracion_accion)* */
ASTNode declaracion_acciones(Globals g) : 
{
  ASTNode accion = null, resul = null, aux = null;
}
{
  try { 
    (
      accion = declaracion_accion(g)
	{
	  if(resul == null) {
	    resul = accion;
	  }
	  else {
	    // Se anida en el punter ASTNode.next
	    aux = resul;
		while(aux.getNext() != null){
			aux = aux.getNext();
		}
		aux.setNext(accion);
	  }
	}
    )*
    { return resul; }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());       
  }
}

/* declaracion_accion ::= cabecera_accion ";"
							declaracion_variables
							declarracion_acciones
							bloque sentencias	*/
ASTNode declaracion_accion(Globals g) : 
{
  ASTNode cabecera = null,
  		  acciones = null,
          sentencias = null;
}
{
  try { 
    cabecera = cabecera_accion(g) ";"
	declaracion_variables(g) 
	acciones = declaracion_acciones(g) 
	sentencias = bloque_sentencias(g)
	{
	  //Eliminamos variables del bloque y bajamos un nivel
	  g.t.eliminar_variables(g.nivel);
	  g.t.eliminar_acciones(g.nivel);
	  g.t.ocultar_parametros(g.nivel);
	  g.t.eliminar_parametros_ocultos(g.nivel+1);
	  g.nivel--;

	  //Generamos rama del árbol AST ( raiz: nodo-accion ; izq: parametros de la accion ; der: bloque_sentencias)
	  cabecera.setNext(acciones);
	  cabecera.setRight(sentencias);

	  return cabecera;
	}
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());  
  }
}

/* cabecera_accion ::= < tACCION > < tIDENTIFICADOR > (parametros_formales)? */
ASTNode cabecera_accion(Globals g) : 
{
  Token t1;
  Simbolo s = null;
  ASTNode resul = null;
 }
{
  try { 
    < tACCION >
    t1 = < tIDENTIFICADOR >
	{
	  //Introduce en la tabla la accion
	  if ( (s = g.t.introducir_accion(t1.image,g.nivel,g.dir)) == null ) {
		// Existe el simbolo en el mismo nivel
		miniLeng.error_semantico("Identificador duplicado", t1);
	  }
	  g.setDireccionInicial();
	  g.nivel++;
	}

   (resul = parametros_formales(g, s))?

   { return resul;  }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());    
  }
}

/* parametros_formales ::= ( "(" parametros ")")? */
ASTNode parametros_formales(Globals g, Simbolo s) : 
{ASTNode params = null; }
{
  try { 
	 "(" (params = parametros(g, s))? ")"
	 {	return params; }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());  
  }
}

/* lista_parametros ::= identificadores (";" paraemtros)? */
ASTNode lista_parametros(Globals g, Simbolo s_accion, Simbolo.TipoVariable tipoVar, Simbolo.ClaseParametro tipoParam) : 
{Token t1, t2;
 ASTNode params = null, aux = null;
 ASTNode resul = new ASTNode(s_accion.getNombre(),ASTNode.TipoNodo.FUN);
}
{
  try { 
    t1 = < tIDENTIFICADOR >
	{
	    s_accion.add_param(); //Aumento el contador de parametros de la accion 
	  //TODO: Puede ser otro tipo de error
		if (g.t.buscar_simbolo(t1.image, g.nivel) != null) { 
		    miniLeng.error_semantico("Identificador duplicado", t1);
		}
		else {
			g.t.introducir_parametro(t1.image, tipoVar, tipoParam, g.nivel, g.dir);
			if (s_accion != null && s_accion.esAccion()) { 
				s_accion.introducir_parametro(t1.image, tipoVar, tipoParam, g.nivel);
				resul.setLeft(new ASTNode(t1.image, tipoVar));
			    resul.getLeft().setType(ASTNode.TipoNodo.VAR);
			    resul.getLeft().setTypeParam(tipoParam);
		        resul.getLeft().setDir(g.dir);
			}
			g.dir++;
		}
	}
     ( "," t2 = < tIDENTIFICADOR >
	{
	  	s_accion.add_param();
		if ( g.t.buscar_simbolo(t2.image, g.nivel) != null) 
		    miniLeng.error_semantico("Identificador duplicado", t2);
		else { 
			g.t.introducir_parametro(t2.image, tipoVar, tipoParam, g.nivel, g.dir);
			if ( s_accion != null && s_accion.esAccion()){
				s_accion.introducir_parametro(t2.image, tipoVar, tipoParam, g.nivel);

				// Se introducen en el arbol AST de forma inversa para poder salvarse en el marco de pila
				aux = resul.getLeft();
		        resul.setLeft(new ASTNode(t2.image, tipoVar));
		        resul.getLeft().setType(ASTNode.TipoNodo.VAR);
		        resul.getLeft().setTypeParam(tipoParam);
		        resul.getLeft().setDir(g.dir);
		        resul.getLeft().setLeft(aux);
		        g.dir++;
			}
		}
	}	
     )*

     ( ";" params = parametros(g, s_accion))?
    {
      // Encadenar el resto de parametros
      if(params != null) {
	      aux = resul.getLeft();
	      resul.setLeft(params);
	      resul.getLeft().setLeft(aux);
  	  }
   	  return resul;
    }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());    
  }
}

/* parametros ::= clase_parametros tipo_variables lista_parametros */
ASTNode parametros(Globals g, Simbolo s) : 
{
  Simbolo.TipoVariable tipoVar;
  Simbolo.ClaseParametro tipoParam;
  ASTNode params = null;
 }
{
  try { 
    tipoParam = clase_parametros(g) tipoVar = tipo_variables(g) params = lista_parametros(g, s, tipoVar, tipoParam)
    {  return params; }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());     
  }
}


/***************************************************************************************************
***************************************************************************************************/
/******************************************* Sentencias *******************************************/

/* bloque_sentencias ::= < tPRINCIPIO > lista_sentencias < tFIN > */
ASTNode bloque_sentencias(Globals g) : 
{ ASTNode resul = null; }
{
  try { 
    < tPRINCIPIO > resul = lista_sentencias(g) < tFIN >
    {
      return resul;
    }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());      
  }
}

/* lista_sentencias ::= ( sentencia )* */
ASTNode lista_sentencias(Globals g) : 
{ ASTNode resul = new ASTNode(), aux;
  ArrayList<ASTNode> sentencias = new ArrayList<ASTNode>();
}
{
  try { 
    ( aux = sentencia(g)
	{
		//Generacion de código
		sentencias.add(aux);
	}
    )*
    {
      aux = resul;
      for(ASTNode sentencia : sentencias) {
		aux.setNext(sentencia);
		aux=sentencia;
      }
      
      return resul.getNext();
    }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());    
  }
}

/* sentencia ::= asignacion | invoacion_accion | mientras_que | leer | escribir | selecion */
ASTNode sentencia(Globals g) : 
{Token t;
 ASTNode resul = null;
}
{
  try { 
	  t = < tIDENTIFICADOR >
	 [ 
		   resul = asignacion(g, t) 		{ return resul;	}
		 | resul = invocacion_accion(g, t)  { return resul;	}
	 ]
	| resul = mientras_que(g) 				{ return resul; }
	| resul = leer(g) ";"					{ return resul; }
	| resul = escribir(g) ";" 				{ return resul; }			
	| resul = seleccion(g) 					{ return resul;	}

	
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());     
  }
}

/* asignacion ::= < tOPAS > expresion ";" */
ASTNode asignacion(Globals g, Token t) :
{
 RegistroExpr r;
 Simbolo s;
 Simbolo.TipoVariable tipo;
 Boolean ok = true;
 ASTNode node = null;
}
{
  try { 
     < tOPAS >
     {
        //TODO: Realizar mas comprobaciones
        // Comprobar que existe el identificador
        if ( (s = g.t.buscar_simbolo(t.image, g.nivel)) == null ){
            miniLeng.error_semantico("Identificador desconocido en la parte izquierda de la asignacion", t);
            tipo = Simbolo.TipoVariable.DESCONOCIDO;
            ok = false;
        }
        else if (s.esParametro() && s.esValor()){
            miniLeng.error_semantico("No se permote realizar una asignacion a un parametro pasado como valor", t);
            tipo = Simbolo.TipoVariable.DESCONOCIDO;
            ok = false;
        }
        else{
            tipo = s.getVariable();
        }
     }
     r = expresion(g) ";"
     {
        //TODO: Realizar mas comprobaciones
        if ( ok && (r.tipo != tipo) && !comparar_tipos(r.tipo, tipo, Simbolo.TipoVariable.DESCONOCIDO,0))
        {
            miniLeng.error_semantico("Tipos incompatibles en la asignacion", t);
        }
        else {
            // Insertar nodo ASG en AST (Left: variable, Right: expresion)
			node = new ASTNode();
			node.setType(ASTNode.TipoNodo.ASG);
			node.setNivel(g.nivel);
			node.setLeft(new ASTNode(t.image, s.getDir()));
			node.setRight(r.nodoAST);
        }
        return node;
     }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());  
  }
}

/* invocacion_accion ::= argumentos ";" */
ASTNode invocacion_accion(Globals g, Token t) :
{
  Simbolo s;
  boolean ok = false;
  ASTNode resul = null;
}
{
  try { 
     {
        //TODO: Realizar mas comprobaciones, buscar por tipo (puede ser una variable)
        // Comprobar que existe el identificador
        if ( (s = g.t.buscar_simbolo(t.image, g.nivel)) == null ){
            miniLeng.error_semantico("Identificador desconocido en la llamada a la accion", t);
        }
        else if (!s.esAccion()){
            miniLeng.error_semantico("No se puede realizar una llamda a una accion sobre un parametro", t);
        }
     }
	 ( resul = argumentos(g, s) { ok=true; })? ";"
	 {
		// Compruebo los parametros de la invocacción en caso de llamarse sin parametros
      	if(!ok && s!= null && s.getNum_params() != 0) {
        	miniLeng.error_semantico("linea " + token.beginLine + "  -  Se esperaban " + s.getNum_params() + " parámetros al invocar a la accion " + s.getNombre());
    	}
    	return resul;
     }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());      
  }
}

/* mientras_que ::= < tMQ > expresion lista_sentencias < tFMQ > */
ASTNode mientras_que(Globals g) :
{ RegistroExpr r; boolean ok;
  ASTNode nodoWhile = null, sentencias;
}
{
  try { 
    < tMQ > r = expresion(g)
     {
        //TODO: Comprobar codigo muerto
        ok = validar_tipo(r.tipo, Simbolo.TipoVariable.BOOLEANO);
        if ( ok && r.clase != Simbolo.ClaseParametro.VAR && r.valorBool == true  ) {
			miniLeng.warning("Generacion de código muerto", token.beginLine);
		}
		else if (ok) {
			nodoWhile = new ASTNode("while", ASTNode.TipoNodo.WHILE);
			nodoWhile.setCond(r.nodoAST);
		}
     }
    sentencias = lista_sentencias(g) < tFMQ >
    {
		nodoWhile.setRight(sentencias);
		return nodoWhile;
    }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());    
  }
}

/* seleccion ::= < tSI > expresion < tENT > lista_sentencias ( < tSI_NO > lista_sentencias )? < tFSI > */
ASTNode seleccion(Globals g) :
{  RegistroExpr r; boolean ok;
   ASTNode nodoSeleccion = null, sentenciasL=null, sentenciasR=null;}
{
  try { 
	 < tSI > r = expresion(g)
     {
        //TODO: Comprobar codigo muerto
        ok=validar_tipo(r.tipo, Simbolo.TipoVariable.BOOLEANO);
        if ( ok && r.clase != Simbolo.ClaseParametro.VAR && r.valorBool == true  ) {
			miniLeng.warning("Generacion de código muerto", token.beginLine);
		}
		else if (ok) {
			nodoSeleccion = new ASTNode("if", ASTNode.TipoNodo.IF);
			nodoSeleccion.setCond(r.nodoAST);
		}
     }
	< tENT >
	sentenciasL = lista_sentencias(g)
	{
	   nodoSeleccion.setLeft(sentenciasL);
	}
	(< tSI_NO >
	{
		// Comprobar que la sentencia no sea true y genere codigo muerto
		if ( ok && r.clase != Simbolo.ClaseParametro.VAR && r.valorBool == true ) {
			miniLeng.warning("Generacion de código muerto", token.beginLine);
		}
	}
	sentenciasR = lista_sentencias(g)
	)?  
	< tFSI >
	{
		nodoSeleccion.setRight(sentenciasR);
		return nodoSeleccion;
    }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage()); 
  }
}

/* leer ::= < tLEER > "(" lista_asignables ")" */
ASTNode leer(Globals g) :
{ ASTNode nodo_leer = null; }
{
  try { 
   <tLEER> "(" nodo_leer = lista_asignables(g) ")"
   { return nodo_leer; }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());    
  }
}

/* escribir ::= < tESCRIBIR > "(" lista_escribibles ")" */
ASTNode escribir(Globals g) :
{ ASTNode resul = null; }
{
  try { 
   <tESCRIBIR> "(" resul = lista_escribibles(g) ")"
   { return resul; }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());     
  }
}

/* lista_asignables ::= identificadores */
ASTNode lista_asignables(Globals g) :
{
  Token t1, t2;
  Simbolo s;
  ASTNode aux = null, resul = new ASTNode("rd", ASTNode.TipoNodo.RD);
}
{
  try {
    // Estructura AST para operación de lectura:
    // Se encadenan las variables en la rama derecha
    //  1ª var - > right, 2ª var right.right ....
  	t1 = < tIDENTIFICADOR>
	{
	   // Comprobar si existe en la tabla de simbolos
	   if ( (s = g.t.buscar_simbolo(t1.image,g.nivel)) == null ) {
	     miniLeng.error_semantico("Identificador desconocido", t1);
	   }
	   else if( s.getTipo() != Simbolo.TipoSimbolo.VARIABLE &&
	   			( !s.esChar() && !s.esCadena() && !s.esEntero())) {
		 miniLeng.error_semantico("Tipo de variable no válida en llamada a leer()", t1);
	   }
	   else {
	     resul.setNivel(g.nivel);
	     // Crea estructura AST
		 resul.setRight(new ASTNode(t1.image, s.getVariable()));
		 resul.getRight().setType(ASTNode.TipoNodo.VAR);
		 resul.getRight().setDir(s.getDir());
	   }
	}
  	( "," t2 = < tIDENTIFICADOR>
	{
	   // Comprobar si existe en la tabla de simbolos
	   if ( (s = g.t.buscar_simbolo(t2.image,g.nivel)) == null ) {
	     miniLeng.error_semantico("Identificador desconocido", t2);
	   }
	   else if( s.getTipo() != Simbolo.TipoSimbolo.VARIABLE &&
	   			( !s.esChar() && !s.esCadena() && !s.esEntero())) {
		 miniLeng.error_semantico("Tipo de variable no válida en llamada a leer()", t1);
	   }
	   else {
	     aux = resul;
	     while(aux.getRight() != null) {
			aux = aux.getRight();
	     }
		 aux.setRight(new ASTNode(t2.image, s.getVariable()));
		 aux.getRight().setType(ASTNode.TipoNodo.VAR);
		 aux.getRight().setDir(s.getDir());
	   }
	}
  	)*
  	{ return resul; }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());      
  }
}

/* lista_escribibles ::= (< tCONSTCAD > | < tCONSTCHAR >) ( "," (< tIDENTIFICADOR > | < tENTACAR >"("expresion")"))* */
ASTNode lista_escribibles(Globals g) : 
{  RegistroExpr r;
   Token t;
   Simbolo s;
   boolean constCad = true;
   ASTNode aux = null, resul = new ASTNode("wr", ASTNode.TipoNodo.WR);
}
{
  try {
    //< tENTACAR > "(" r = expresion(g) ")"
   ( t = < tCONSTCAD > | t = < tCONSTCHAR > |  t = < tIDENTIFICADOR > { constCad = false; })
	{
		if (constCad) {
			 resul.setRight(new ASTNode(t.image, Simbolo.TipoVariable.CADENA));
			 resul.getRight().setType(ASTNode.TipoNodo.CONST);
		}
		else {
		    if ( (s = g.t.buscar_simbolo(t.image,g.nivel)) == null ) {
	           miniLeng.error_semantico("Identificador desconocido", t);
	        }
	        else if( s.getTipo() != Simbolo.TipoSimbolo.VARIABLE && (!s.esChar() && !s.esCadena())) {
		      miniLeng.error_semantico("Tipo de variable no válida en llamada a escribir()", t);
	        }
	        else {
	          resul.setNivel(g.nivel);
	          resul.setRight(new ASTNode(t.image, s.getVariable()));
			  resul.getRight().setType(ASTNode.TipoNodo.VAR);
			  resul.getRight().setTypeParam(s.getParametro());
			  resul.getRight().setDir(s.getDir());
	        }
	     }
	     constCad = true;
	}
   ( ","  ( t = < tCONSTCAD > | t = < tCONSTCHAR > |  t = < tIDENTIFICADOR > { constCad = false; })
	{
		if (constCad) {
	         aux = resul;
	         while(aux.getRight() != null) {
			    aux = aux.getRight();
	         }		  
		     aux.setRight(new ASTNode(t.image, Simbolo.TipoVariable.CADENA));
		     aux.getRight().setType(ASTNode.TipoNodo.CONST);
		}
		else {
		    if ( (s = g.t.buscar_simbolo(t.image,g.nivel)) == null ) {
	           miniLeng.error_semantico("Identificador desconocido", t);
	        }
	        else if( s.getTipo() != Simbolo.TipoSimbolo.VARIABLE && (!s.esChar() && !s.esCadena())) {
		      miniLeng.error_semantico("Tipo de variable no válida en llamada a escribir()", t);
	        }
	        else {
	             aux = resul;
	             while(aux.getRight() != null) {
			        aux = aux.getRight();
	             }		  
		         aux.setRight(new ASTNode(t.image, s.getVariable()));
		         aux.getRight().setDir(s.getDir());
		         aux.getRight().setType(ASTNode.TipoNodo.VAR);
		         aux.getRight().setTypeParam(s.getParametro());
	        }
	     }
	     constCad = true;
	}	
   )*
  {
    return resul;
  }
  }
  catch (Exception e) {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());     
  }
}

/* argumentos ::= ( "(" lista_expresiones ")" )? */
ASTNode argumentos(Globals g, Simbolo s) : 
{
  boolean ok=false;
  ASTNode resul = null;
}
{
  try { 
    "(" ( resul = lista_expresiones(g, s) { ok=true; })? ")"
    {
		// Compruebo los parametros de la invocacción en caso de llamarse sin parametros
      	if(!ok && s != null && s.getNum_params() != 0) {
        	miniLeng.error_semantico("linea " + token.beginLine + "  -  Se esperaban " + s.getNum_params() + " parámetros al invocar a la accion " + s.getNombre());	
    	}
    	return resul;
    }
    
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());    
  }
}

/* lista_expresiones ::= expresion ( "," expresion)* */
ASTNode lista_expresiones(Globals g, Simbolo s) : 
{
  RegistroExpr r;
  int num_params = 0;
  ArrayList<Simbolo> parametros = s.getLista_simbolos();
  ArrayList<RegistroExpr> params = new ArrayList<RegistroExpr>();
  ASTNode resul = new ASTNode();
}
{
  try { 
    r = expresion(g) { num_params++; params.add(r); }
    ( "," r = expresion(g) { num_params++; params.add(r);  })*
    {
		// Comprobar que los parametros de llamada a la funcion coindicen con los de la tabla
		if (s.getNum_params() != num_params) {
			miniLeng.error_semantico("El número de parámetros de llamada a la función " + s.getNombre() + " no coindice");
		}
		else{
			// Comprobar cada tipo
			for(Simbolo accion_param : s.getLista_simbolos()) {

			  	r = params.get(0);
			  	if (r.clase == Simbolo.ClaseParametro.VAL && accion_param.esValor() ) {
			  	  miniLeng.error_semantico("No se puede pasar un parámetro por valor como referencia en la invocación a la accion");
			  	}
				if(!miniLeng.validar_tipo(r.tipo, accion_param.getVariable())) {
				  break;
				}
				params.remove(0);
			}
		}
		return resul;
    }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());     
  }
}

/* expresion ::= expresion_simple | (operador_relacional expresion_simple)* */
RegistroExpr expresion(Globals g) : 
{ RegistroExpr r1,r2 = null;
  Simbolo.TipoOperador op;
  RegistroExpr resul = new RegistroExpr();
  Boolean ok;
}
{
  try { 
	r1 = expresion_simple(g)
	(op =operador_relacional(g)
	 r2 = expresion_simple(g)
	{
		if((r1.tipo != r2.tipo) && !comparar_tipos(r1.tipo,r2.tipo, Simbolo.TipoVariable.DESCONOCIDO,0)) {
		    miniLeng.error_semantico("Los operandos deben ser del mismo tipo");
		    resul.tipo = Simbolo.TipoVariable.DESCONOCIDO;
		}
		else {
		  	if (r1.clase == Simbolo.ClaseParametro.VAR || r1.clase == Simbolo.ClaseParametro.VAR ) { 
		    	resul.clase = Simbolo.ClaseParametro.VAR;
			}
			else {
			    resul.clase = Simbolo.ClaseParametro.CONST;
			}
		    resul.tipo = Simbolo.TipoVariable.BOOLEANO;
		    //Generacion de código
			resul.nodoAST = new ASTNode();
       		miniLeng.createSubTreeAST(resul.nodoAST, r2.nodoAST, r1.nodoAST, ASTNode.TipoNodo.COND,op);
			
		    // Análisis semántico
		    switch (r1.tipo) {
				case ENTERO:
					ok = validar_tipo(r2.tipo, Simbolo.TipoVariable.ENTERO);
					if ( !ok )
						resul.tipo = Simbolo.TipoVariable.DESCONOCIDO;
					else {
					    switch (op) {
                   			case GT:
                        		resul.valorBool = r1.valorEnt > r2.valorEnt;
            		    		break;
            	    		case LT:
                        		resul.valorBool = r1.valorEnt < r2.valorEnt;
            		    		break;
            	    		case GE:
                        		resul.valorBool = r1.valorEnt >= r2.valorEnt;
            					break;
            	    		case LE:
                        		resul.valorBool = r1.valorEnt <= r2.valorEnt;
            					break;
             	    		case EQ:
                         		resul.valorBool = r1.valorEnt == r2.valorEnt;
             					break;
            	    		case NE:
                        		resul.valorBool = r1.valorEnt != r2.valorEnt;
            					break;
            	    		default:
            		    		break;
                		}
              		}
					break;
				case CADENA:
					ok = validar_tipo(r2.tipo, Simbolo.TipoVariable.CADENA);
					if ( !ok )
						resul.tipo = Simbolo.TipoVariable.DESCONOCIDO;
					else {
					    switch (op) {
             	    		case EQ:
                         		resul.valorBool = r1.valorString.equals(r2.valorString);
             					break;
            	    		case NE:
                        		resul.valorBool = !r1.valorString.equals(r2.valorString);
            					break;
            	    		default:
            	    		    miniLeng.error_semantico("No se puede utilizar el operador " + op + " sobre una cadena");
            		    		break;
                		}
              		}
					break;
				case BOOLEANO:
					ok = validar_tipo(r2.tipo, Simbolo.TipoVariable.BOOLEANO);
					if ( !ok )
						resul.tipo = Simbolo.TipoVariable.DESCONOCIDO;
					else {
					    switch (op) {
             	    		case EQ:
                         		resul.valorBool = r1.valorBool == r2.valorBool;
             					break;
            	    		case NE:
                        		resul.valorBool = r1.valorBool != r2.valorBool;
            					break;
            	    		default:
            	    		    miniLeng.error_semantico("No se puede utilizar la operador " + op + " sobre un booleano");
            		    		break;
                		}
              		}				
					break;
				case DESCONOCIDO:
					resul.tipo = Simbolo.TipoVariable.DESCONOCIDO; 
				default: // DESCONOCIDO
					break;
		    }
		}
	}
	)*
	{
	  if (r2 == null)
	    return r1;
	  else
	    return resul;
	}
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());       
  }
}

/* expresion_simple ::= termino (operador_aditivo termino)* */
RegistroExpr expresion_simple(Globals g) : 
{
  RegistroExpr r1, r2=null;
  RegistroExpr resul = new RegistroExpr();
  Simbolo.TipoOperador op;
  Boolean ok;
}
{
  try { 
	r1 = termino(g)
	( op = operador_aditivo(g)
	  r2 = termino(g)
	{
	  ok = true;
	  //TODO: Comproboar overflow/underflow
	  switch (op) {
		case SUMA:
		    ok = validar_tipo(r1.tipo, Simbolo.TipoVariable.ENTERO)
		        && validar_tipo(r2.tipo, Simbolo.TipoVariable.ENTERO);
		    if ( ok && comparar_tipos(r1.tipo,r2.tipo,Simbolo.TipoVariable.ENTERO,1))
            {
                resul.tipo = Simbolo.TipoVariable.ENTERO;
                resul.valorEnt = r1.valorEnt + r2.valorEnt;
            }
            else {
                resul.tipo = Simbolo.TipoVariable.DESCONOCIDO;
            }
			break;
		case RESTA:
		    ok = validar_tipo(r1.tipo, Simbolo.TipoVariable.ENTERO)
		        && validar_tipo(r2.tipo, Simbolo.TipoVariable.ENTERO);
		    if ( ok && comparar_tipos(r1.tipo,r2.tipo,Simbolo.TipoVariable.ENTERO,1))
            {
                resul.tipo = Simbolo.TipoVariable.ENTERO;
                resul.valorEnt = r1.valorEnt - r2.valorEnt;
            }
            else {
                resul.tipo = Simbolo.TipoVariable.DESCONOCIDO;
            }
			break;
		case OR:
		    ok = validar_tipo(r1.tipo, Simbolo.TipoVariable.BOOLEANO)
		        && validar_tipo(r2.tipo, Simbolo.TipoVariable.BOOLEANO);
		    if ( ok && comparar_tipos(r1.tipo,r2.tipo,Simbolo.TipoVariable.BOOLEANO,1))
            {
                resul.tipo = Simbolo.TipoVariable.BOOLEANO;
                resul.valorBool = r1.valorBool | r2.valorBool;
            }
            else {
                resul.tipo = Simbolo.TipoVariable.DESCONOCIDO;
            }
			break;
		default:
			break;
	   }
	   // Generación de código
	   resul.nodoAST = new ASTNode();
       miniLeng.createSubTreeAST(resul.nodoAST, r2.nodoAST, r1.nodoAST, ASTNode.TipoNodo.OP,op);
	}
	)*
	{
	  if (r2 == null)
	    return r1;
	  else
	    return resul;
	}  
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());      
  }
}

/* termino ::= factor (operador multiplicativo factor)* */
RegistroExpr termino(Globals g) : 
{
  RegistroExpr r1, r2=null;
  RegistroExpr resul = new RegistroExpr();
  Simbolo.TipoOperador op;
  Boolean ok;

}
{
  try { 
    r1 = factor(g)
    ( op = operador_multiplicativo(g)
      r2 = factor(g)
{
	  //TODO: Comproboar overflow/underflow
	  switch (op) {
		case MUL:
		    ok = validar_tipo(r1.tipo, Simbolo.TipoVariable.ENTERO)
		        && validar_tipo(r2.tipo, Simbolo.TipoVariable.ENTERO);
		    if ( ok && comparar_tipos(r1.tipo,r2.tipo,Simbolo.TipoVariable.ENTERO,1))
            {
                resul.tipo = Simbolo.TipoVariable.ENTERO;
                resul.valorEnt = r1.valorEnt * r2.valorEnt;
            }
            else {
                resul.tipo = Simbolo.TipoVariable.DESCONOCIDO;
            }
			break;
		case DIV:
		    ok = validar_tipo(r1.tipo, Simbolo.TipoVariable.ENTERO)
		        && validar_tipo(r2.tipo, Simbolo.TipoVariable.ENTERO);
		    //TODO: COMPROBAR DIVISION POR 0
		    if ( ok && comparar_tipos(r1.tipo,r2.tipo,Simbolo.TipoVariable.ENTERO,1))
            {
                if ( r2.valorEnt == 0 ) {
                    miniLeng.error_semantico("Division por 0", token);
                    resul.tipo = Simbolo.TipoVariable.DESCONOCIDO;
                }
                else{
                    resul.tipo = Simbolo.TipoVariable.ENTERO;
                    resul.valorEnt = r1.valorEnt / r2.valorEnt;
                }
            }
            else {
                resul.tipo = Simbolo.TipoVariable.DESCONOCIDO;
            }
			break;
		case MOD:
		    ok = validar_tipo(r1.tipo, Simbolo.TipoVariable.ENTERO)
		        && validar_tipo(r2.tipo, Simbolo.TipoVariable.ENTERO);
            //TODO: COMPROBAR MOD POR 0
		    if ( ok && comparar_tipos(r1.tipo,r2.tipo,Simbolo.TipoVariable.ENTERO,1))
            {
                if ( r2.valorEnt == 0 ) {
                    miniLeng.error_semantico("Operacion modulo por 0");
                    resul.tipo = Simbolo.TipoVariable.DESCONOCIDO;
                }
                else{
                    resul.tipo = Simbolo.TipoVariable.ENTERO;
                    resul.valorEnt = r1.valorEnt / r2.valorEnt;
                }
            }
            else {
                resul.tipo = Simbolo.TipoVariable.DESCONOCIDO;
            }
			break;
		case AND:
		    ok = validar_tipo(r1.tipo, Simbolo.TipoVariable.BOOLEANO)
		        && validar_tipo(r2.tipo, Simbolo.TipoVariable.BOOLEANO);
		    if ( ok && comparar_tipos(r1.tipo,r2.tipo,Simbolo.TipoVariable.BOOLEANO,1))
            {
                resul.tipo = Simbolo.TipoVariable.BOOLEANO;
                resul.valorBool = r1.valorBool & r2.valorBool;
            }
            else {
                resul.tipo = Simbolo.TipoVariable.DESCONOCIDO;
            }
			break;
		default:
			break;
	   }
	   
       // Generacion de codigo
       resul.nodoAST = new ASTNode();
       miniLeng.createSubTreeAST(resul.nodoAST, r1.nodoAST, r2.nodoAST, ASTNode.TipoNodo.OP,op);
	}

    )*
    {
	  if (r2 == null)
	    return r1;
	  else
	    return resul;
	}  
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());   
  }
}

RegistroExpr factor(Globals g) : 
{
  Token t;
  Simbolo s;
  RegistroExpr r1,resul = new RegistroExpr();
  Simbolo.TipoVariable tipoVar;
}
{
  try { 
    "-" r1 = factor(g)
  {
    // Comprobar si es del tipo ENTERO o DESCONOCIDO
	if ( (r1.tipo != Simbolo.TipoVariable.ENTERO)
	     && (r1.tipo != Simbolo.TipoVariable.DESCONOCIDO)) {
      miniLeng.error_semantico("Tipo incompatible, se esperaba entero");
      resul.tipo = Simbolo.TipoVariable.DESCONOCIDO;
    }
    else {
      resul.tipo = Simbolo.TipoVariable.ENTERO;
    }
    return resul;
  }
 |  < tNOT > r1 = factor(g)
 {
    // Comprobar si es del tipo BOOL o DESCONOCIDO
	if ( (r1.tipo != Simbolo.TipoVariable.BOOLEANO)
	     && (r1.tipo != Simbolo.TipoVariable.DESCONOCIDO)) {
      miniLeng.error_semantico("Tipo incompatible, se esperaba booleano");
      resul.tipo = Simbolo.TipoVariable.DESCONOCIDO;
    }
    else {
      resul.tipo = Simbolo.TipoVariable.BOOLEANO;
    }
    return resul;
 }
 |  "(" r1 = expresion(g) ")"
 {
   return r1;
 }
 |  < tENTACAR > "(" r1 = expresion(g) ")"
 {
    // Comprobar si es del tipo ENTERO o DESCONOCIDO
	if ( (r1.tipo != Simbolo.TipoVariable.ENTERO)
	     && (r1.tipo != Simbolo.TipoVariable.DESCONOCIDO)) {
      miniLeng.error_semantico("La expresion no se puede convertir en un carácter válido");
      resul.tipo = Simbolo.TipoVariable.DESCONOCIDO;
    }
    else {
      resul.tipo = Simbolo.TipoVariable.CHAR;
    }
    return resul;
 }
 |  < tCARAENT > "(" r1 = expresion(g) ")"
 {
    // Comprobar si es del tipo CHAR o DESCONOCIDO
	if ( (r1.tipo != Simbolo.TipoVariable.CHAR)
	     && (r1.tipo != Simbolo.TipoVariable.DESCONOCIDO)) {
      miniLeng.error_semantico("La expresion no se puede convertir en un valor válido");
      resul.tipo = Simbolo.TipoVariable.DESCONOCIDO;
    }
    else {
      resul.tipo = Simbolo.TipoVariable.CHAR;
    }
    return resul;
 }
 |  t = < tIDENTIFICADOR >
 {
   // Comprobar si existe en la tabla de simbolos
   if ( (s = g.t.buscar_simbolo(t.image,g.nivel)) == null ) {
     miniLeng.error_semantico("Identificador desconocido", t);
     resul.tipo = Simbolo.TipoVariable.DESCONOCIDO;
   }
   else {
     resul.tipo = s.getVariable();
     resul.clase = (s.getParametro() != null) ? s.getParametro() : Simbolo.ClaseParametro.VAR;
     //resul.clase = s.getParametro();
     resul.nodoAST = new ASTNode(t.image, ASTNode.TipoNodo.VAR);
     resul.nodoAST.setDir(s.getDir());
     resul.nodoAST.setNivel(s.getNivel());
     resul.nodoAST.setTypeParam(s.getParametro());
   }
   return resul;
 }
 |  t = < tCONSTCHAR >
 {
   resul.valorString = t.image;
   resul.tipo = Simbolo.TipoVariable.CHAR;
   resul.nodoAST = new ASTNode(t.image);
   resul.nodoAST.setType(ASTNode.TipoNodo.CONST);
   resul.nodoAST.setTypeVar(Simbolo.TipoVariable.CADENA);
   return resul;
 }
 |  t = < tCONSTCAD >
 {
   resul.valorString = t.image;
   resul.tipo = Simbolo.TipoVariable.CADENA;
   resul.nodoAST = new ASTNode(t.image);
   resul.nodoAST.setType(ASTNode.TipoNodo.CONST);
   resul.nodoAST.setTypeVar(Simbolo.TipoVariable.CADENA);
   return resul;
 }
 |  t = < tCONSTENTERA >
 {
   resul.valorEnt = Integer.parseInt(t.image);
   resul.tipo = Simbolo.TipoVariable.ENTERO;
   resul.nodoAST = new ASTNode(resul.valorEnt);
   resul.nodoAST.setType(ASTNode.TipoNodo.CONST);
   resul.nodoAST.setTypeVar(Simbolo.TipoVariable.ENTERO);
   return resul;
 }
 |  < tTRUE >
 {
   resul.valorBool = true;
   resul.tipo = Simbolo.TipoVariable.BOOLEANO;
   // Se utiliza 1 como entero para guardar una constante TRUE
   resul.nodoAST = new ASTNode(1);
   resul.nodoAST.setType(ASTNode.TipoNodo.CONST);
   resul.nodoAST.setTypeVar(Simbolo.TipoVariable.BOOLEANO);
   return resul;
 }
 |  < tFALSE >
 {
   resul.valorBool = false;
   resul.tipo = Simbolo.TipoVariable.BOOLEANO;
   // Se utiliza 0 como entero para guardar una constante FALSE
   resul.nodoAST = new ASTNode(0);
   resul.nodoAST.setType(ASTNode.TipoNodo.CONST);
   resul.nodoAST.setTypeVar(Simbolo.TipoVariable.BOOLEANO);
   return resul;
 }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());   
  }
}

/***************************************************************************************************
***************************************************************************************************/
/******************************************** Tipo ************************************************/

/* tipo_variables ::= < tENTERO > | < tCARACTER > | < tBOOLEANO > */
Simbolo.TipoVariable tipo_variables(Globals g) :
{}
{
  try {
    < tENTERO >    { return Simbolo.TipoVariable.ENTERO; }
|   < tCARACTER >  { return Simbolo.TipoVariable.CADENA; }
|   < tBOOLEANO >  { return Simbolo.TipoVariable.BOOLEANO; }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());
  }
}

/* clase_parametros ::= < tVAL > | < tREF > */
Simbolo.ClaseParametro clase_parametros(Globals g) :
{}
{
  try {
    < tVAL > { return Simbolo.ClaseParametro.VAL; }
 |  < tREF > { return Simbolo.ClaseParametro.REF; }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());
  }
}

Simbolo.TipoOperador operador_relacional(Globals g) :
{}
{
  try {
    	< tMAYOR >      { return Simbolo.TipoOperador.GT; }
  | 	< tMENOR >      { return Simbolo.TipoOperador.LT; }
  | 	< tIGUAL >      { return Simbolo.TipoOperador.EQ; }
  | 	< tMAI >        { return Simbolo.TipoOperador.GE; }
  | 	< tMEI  >       { return Simbolo.TipoOperador.LE; }
  | 	< tNI >         { return Simbolo.TipoOperador.NE; }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());
  }
}

Simbolo.TipoOperador operador_aditivo(Globals g) :
{}
{
  try {
    "+" 		{ return Simbolo.TipoOperador.SUMA; }
    | "-"	    { return Simbolo.TipoOperador.RESTA; }
    | < tOR >   { return Simbolo.TipoOperador.OR; }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());
  }
}

Simbolo.TipoOperador operador_multiplicativo(Globals g) :
{}
{
  try {
    "*"            { return Simbolo.TipoOperador.MUL; }
    | < tDIV >     { return Simbolo.TipoOperador.DIV; }
    | < tMOD >     { return Simbolo.TipoOperador.MOD; }
    | < tAND >     { return Simbolo.TipoOperador.AND; }
  }
  catch (Exception e)
  {
	miniLeng.tratarErrorSintactico(token.next.beginLine, token.next.beginColumn, token.next.image);
	System.out.println(e.getMessage());
  }
}

/***************************************************************************************************
***************************************************************************************************/
/******************************************** Tokens **********************************************/

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
| "%" : COMMENT 
}

< COMMENT > SKIP :
{
  "\n" : DEFAULT
}

<COMMENT> MORE : {
	<~[]>
}

TOKEN : /*  Reservadas */
{
	< tPROGRAMA : "programa" > 
| 	< tVAR : "var" >
| 	< tAND: "and" >
| 	< tOR: "or" >
| 	< tNOT: "not" >
| 	< tPRINCIPIO : "principio" > 
| 	< tFIN: "fin" > 
| 	< tSI: "si" >
| 	< tENT: "ent" >
| 	< tSI_NO : "si_no" >
| 	< tFSI: "fsi" >
| 	< tMQ: "mq" >
| 	< tFMQ: "fmq" >
| 	< tESCRIBIR : "escribir" >
| 	< tLEER: "leer" >
| 	< tMOD: "mod" >
| 	< tDIV: "div" >
| 	< tENTERO: "entero" >
| 	< tBOOLEANO: "booleano" >
| 	< tCARACTER : "caracter" >
| 	< tTRUE: "true" >
| 	< tFALSE: "false" >
| 	< tENTACAR: "entacar" >
| 	< tCARAENT: "caraent" >
| 	< tACCION: "accion" >
| 	< tVAL : "val" >
| 	< tREF: "ref" >
| 	< tMAYOR: ">" >
| 	< tMENOR: "<" >
| 	< tIGUAL: "=" >
| 	< tMAI: ">=" >
| 	< tMEI : "<=" >
| 	< tNI: "<>" >
| 	< tOPAS: ":=" >
}

TOKEN :   /* Digits */
{
  < tCONSTENTERA : (< DIGIT >)+ >
| < tREAL : (< DIGIT >)+ "." (< DIGIT >)+ >
| < #DIGIT : [ "0"-"9" ] >
}


TOKEN : {
 < tIDENTIFICADOR: <LETTER> ((<LETTER> | <DIGIT>)* (["A"-"Z","a"-"z","0"-"9"]) )? >
| < #LETTER: ["A"-"Z","_","a"-"z"] >
| < tCONSTCHAR : "\'"  (~["\'","\\","\n","\r"] |  "\\" ["n","t","b","r","f","\\","\'","\""])*  "\'" >
| < tCONSTCAD  : "\""  (~["\'","\\","\n","\r"] |  "\\" ["n","t","b","r","f","\\","\'","\""])*  "\"" >
}


